// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
  RpcVersion,
  RpcV2,
  ISubmittableExtrinsicLegacy,
} from 'dedot/types';
import type {
  MultiAddressLike,
  Extrinsic,
  BytesLike,
  H256,
  AccountId32Like,
  Data,
  FixedBytes,
} from 'dedot/codecs';
import type {
  MelodieRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  MelodieRuntimeRuntimeTask,
  PalletBalancesAdjustmentDirection,
  SpConsensusSlotsEquivocationProof,
  SpSessionMembershipProof,
  SpConsensusBabeDigestsNextConfigDescriptor,
  PalletImOnlineHeartbeat,
  PalletImOnlineSr25519AppSr25519Signature,
  MelodieRuntimePalletsSessionSessionKeys,
  SpConsensusGrandpaEquivocationProof,
  MelodieRuntimeOriginCaller,
  SpWeightsWeightV2Weight,
  SharedRuntimeIdentityIdentityInfo,
  PalletIdentityJudgement,
  MelodieRuntimePalletsProxyProxyType,
  PalletMultisigTimepoint,
  MiddsStakeholderStakeholder,
  MiddsStakeholderEditableStakeholderField,
  MiddsSongSong,
  MiddsSongSongEditableField,
} from './types';

export type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = MelodieRuntimeRuntimeCallLike,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord>>);

export type TxCall<Rv extends RpcVersion> = (
  ...args: any[]
) => ChainSubmittableExtrinsic<Rv>;

export interface ChainTx<Rv extends RpcVersion>
  extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     *
     * @param {MelodieRuntimeRuntimeTask} task
     **/
    doTask: GenericTxCall<
      Rv,
      (task: MelodieRuntimeRuntimeTask) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'DoTask';
            params: { task: MelodieRuntimeRuntimeTask };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: {
              source: MultiAddressLike;
              dest: MultiAddressLike;
              value: bigint;
            };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: {
              direction: PalletBalancesAdjustmentDirection;
              delta: bigint;
            };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Babe`'s transaction calls
   **/
  babe: {
    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocation';
            params: {
              equivocationProof: SpConsensusSlotsEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: {
              equivocationProof: SpConsensusSlotsEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     *
     * @param {SpConsensusBabeDigestsNextConfigDescriptor} config
     **/
    planConfigChange: GenericTxCall<
      Rv,
      (
        config: SpConsensusBabeDigestsNextConfigDescriptor,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'PlanConfigChange';
            params: { config: SpConsensusBabeDigestsNextConfigDescriptor };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ImOnline`'s transaction calls
   **/
  imOnline: {
    /**
     * ## Complexity:
     * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
     * - `O(K)`: decoding of length `K`
     *
     * @param {PalletImOnlineHeartbeat} heartbeat
     * @param {PalletImOnlineSr25519AppSr25519Signature} signature
     **/
    heartbeat: GenericTxCall<
      Rv,
      (
        heartbeat: PalletImOnlineHeartbeat,
        signature: PalletImOnlineSr25519AppSr25519Signature,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ImOnline';
          palletCall: {
            name: 'Heartbeat';
            params: {
              heartbeat: PalletImOnlineHeartbeat;
              signature: PalletImOnlineSr25519AppSr25519Signature;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ValidatorSet`'s transaction calls
   **/
  validatorSet: {
    /**
     * Add a new validator.
     *
     * New validator's session keys should be set in Session pallet before
     * calling this.
     *
     * The origin can be configured using the `AddRemoveOrigin` type in the
     * host runtime. Can also be set to sudo/root.
     *
     * @param {AccountId32Like} validatorId
     **/
    addValidator: GenericTxCall<
      Rv,
      (validatorId: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ValidatorSet';
          palletCall: {
            name: 'AddValidator';
            params: { validatorId: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Remove a validator.
     *
     * The origin can be configured using the `AddRemoveOrigin` type in the
     * host runtime. Can also be set to sudo/root.
     *
     * @param {AccountId32Like} validatorId
     **/
    removeValidator: GenericTxCall<
      Rv,
      (validatorId: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ValidatorSet';
          palletCall: {
            name: 'RemoveValidator';
            params: { validatorId: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {MelodieRuntimePalletsSessionSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      Rv,
      (
        keys: MelodieRuntimePalletsSessionSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'SetKeys';
            params: {
              keys: MelodieRuntimePalletsSessionSessionKeys;
              proof: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'PurgeKeys';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Grandpa`'s transaction calls
   **/
  grandpa: {
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocation';
            params: {
              equivocationProof: SpConsensusGrandpaEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: {
              equivocationProof: SpConsensusGrandpaEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     *
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     *
     * Only callable by root.
     *
     * @param {number} delay
     * @param {number} bestFinalizedBlockNumber
     **/
    noteStalled: GenericTxCall<
      Rv,
      (
        delay: number,
        bestFinalizedBlockNumber: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'NoteStalled';
            params: { delay: number; bestFinalizedBlockNumber: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<MelodieRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (
        calls: Array<MelodieRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: MelodieRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<MelodieRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (
        calls: Array<MelodieRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {MelodieRuntimeOriginCaller} asOrigin
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: MelodieRuntimeOriginCaller,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: {
              asOrigin: MelodieRuntimeOriginCaller;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<MelodieRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (
        calls: Array<MelodieRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {MelodieRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: MelodieRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: {
              call: MelodieRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * @param {MultiAddressLike} account
     **/
    addRegistrar: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddRegistrar';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * @param {SharedRuntimeIdentityIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      Rv,
      (info: SharedRuntimeIdentityIdentityInfo) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetIdentity';
            params: { info: SharedRuntimeIdentityIdentityInfo };
          };
        }
      >
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * @param {Array<[AccountId32Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      Rv,
      (subs: Array<[AccountId32Like, Data]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetSubs';
            params: { subs: Array<[AccountId32Like, Data]> };
          };
        }
      >
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     **/
    clearIdentity: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ClearIdentity';
          };
        }
      >
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RequestJudgement';
            params: { regIndex: number; maxFee: bigint };
          };
        }
      >
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      Rv,
      (regIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'CancelRequest';
            params: { regIndex: number };
          };
        }
      >
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      Rv,
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFee';
            params: { index: number; fee: bigint };
          };
        }
      >
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * @param {number} index
     * @param {MultiAddressLike} new_
     **/
    setAccountId: GenericTxCall<
      Rv,
      (
        index: number,
        new_: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetAccountId';
            params: { index: number; new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * @param {number} index
     * @param {bigint} fields
     **/
    setFields: GenericTxCall<
      Rv,
      (
        index: number,
        fields: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFields';
            params: { index: number; fields: bigint };
          };
        }
      >
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     *
     * @param {number} regIndex
     * @param {MultiAddressLike} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        target: MultiAddressLike,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ProvideJudgement';
            params: {
              regIndex: number;
              target: MultiAddressLike;
              judgement: PalletIdentityJudgement;
              identity: H256;
            };
          };
        }
      >
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * @param {MultiAddressLike} target
     **/
    killIdentity: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillIdentity';
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RenameSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     **/
    removeSub: GenericTxCall<
      Rv,
      (sub: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveSub';
            params: { sub: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'QuitSub';
          };
        }
      >
    >;

    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up their allocation, they
     * should just issue (or request via governance) a new `add_username_authority` call.
     *
     * @param {MultiAddressLike} authority
     * @param {BytesLike} suffix
     * @param {number} allocation
     **/
    addUsernameAuthority: GenericTxCall<
      Rv,
      (
        authority: MultiAddressLike,
        suffix: BytesLike,
        allocation: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddUsernameAuthority';
            params: {
              authority: MultiAddressLike;
              suffix: BytesLike;
              allocation: number;
            };
          };
        }
      >
    >;

    /**
     * Remove `authority` from the username authorities.
     *
     * @param {MultiAddressLike} authority
     **/
    removeUsernameAuthority: GenericTxCall<
      Rv,
      (authority: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsernameAuthority';
            params: { authority: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * The authority must have an `allocation`. Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     *
     * @param {MultiAddressLike} who
     * @param {BytesLike} username
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    setUsernameFor: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        username: BytesLike,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetUsernameFor';
            params: {
              who: MultiAddressLike;
              username: BytesLike;
              signature: SpRuntimeMultiSignature | undefined;
            };
          };
        }
      >
    >;

    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    acceptUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AcceptUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    removeExpiredApproval: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveExpiredApproval';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Set a given username as the primary. The username should include the suffix.
     *
     * @param {BytesLike} username
     **/
    setPrimaryUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetPrimaryUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove a username that corresponds to an account with no identity. Exists when a user
     * gets a username but then calls `clear_identity`.
     *
     * @param {BytesLike} username
     **/
    removeDanglingUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveDanglingUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      Rv,
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Schedule';
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Cancel';
            params: { when: number; index: number };
          };
        }
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamed';
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      Rv,
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleAfter';
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamedAfter';
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      Rv,
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetry';
            params: { task: [number, number]; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetryNamed';
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      Rv,
      (task: [number, number]) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetry';
            params: { task: [number, number] };
          };
        }
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetryNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Sudo`'s transaction calls
   **/
  sudo: {
    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     *
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    sudo: GenericTxCall<
      Rv,
      (call: MelodieRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'Sudo';
            params: { call: MelodieRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {MelodieRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    sudoUncheckedWeight: GenericTxCall<
      Rv,
      (
        call: MelodieRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SudoUncheckedWeight';
            params: {
              call: MelodieRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     *
     * @param {MultiAddressLike} new_
     **/
    setKey: GenericTxCall<
      Rv,
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SetKey';
            params: { new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {MultiAddressLike} who
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    sudoAs: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SudoAs';
            params: {
              who: MultiAddressLike;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Permanently removes the sudo key.
     *
     * **This cannot be un-done.**
     *
     **/
    removeKey: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'RemoveKey';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {MelodieRuntimePalletsProxyProxyType | undefined} forceProxyType
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: MultiAddressLike;
              forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: MelodieRuntimePalletsProxyProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: {
              delegate: MultiAddressLike;
              proxyType: MelodieRuntimePalletsProxyProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: MelodieRuntimePalletsProxyProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: {
              delegate: MultiAddressLike;
              proxyType: MelodieRuntimePalletsProxyProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: MelodieRuntimePalletsProxyProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: {
              proxyType: MelodieRuntimePalletsProxyProxyType;
              delay: number;
              index: number;
            };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: MultiAddressLike,
        proxyType: MelodieRuntimePalletsProxyProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: MultiAddressLike;
              proxyType: MelodieRuntimePalletsProxyProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {MelodieRuntimePalletsProxyProxyType | undefined} forceProxyType
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId32Like>,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: {
              otherSignatories: Array<AccountId32Like>;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {MelodieRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: MelodieRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: MelodieRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      Rv,
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'NotePreimage';
            params: { bytes: BytesLike };
          };
        }
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnnotePreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'RequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnrequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Ensure that the a bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      Rv,
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'EnsureUpdated';
            params: { hashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Stakeholders`'s transaction calls
   **/
  stakeholders: {
    /**
     *
     * @param {MiddsStakeholderStakeholder} midds
     **/
    register: GenericTxCall<
      Rv,
      (midds: MiddsStakeholderStakeholder) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Stakeholders';
          palletCall: {
            name: 'Register';
            params: { midds: MiddsStakeholderStakeholder };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     * @param {MiddsStakeholderEditableStakeholderField} fieldData
     **/
    updateField: GenericTxCall<
      Rv,
      (
        middsId: H256,
        fieldData: MiddsStakeholderEditableStakeholderField,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Stakeholders';
          palletCall: {
            name: 'UpdateField';
            params: {
              middsId: H256;
              fieldData: MiddsStakeholderEditableStakeholderField;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     **/
    unregister: GenericTxCall<
      Rv,
      (middsId: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Stakeholders';
          palletCall: {
            name: 'Unregister';
            params: { middsId: H256 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MusicalWorks`'s transaction calls
   **/
  musicalWorks: {
    /**
     *
     * @param {MiddsSongSong} midds
     **/
    register: GenericTxCall<
      Rv,
      (midds: MiddsSongSong) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MusicalWorks';
          palletCall: {
            name: 'Register';
            params: { midds: MiddsSongSong };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     * @param {MiddsSongSongEditableField} fieldData
     **/
    updateField: GenericTxCall<
      Rv,
      (
        middsId: H256,
        fieldData: MiddsSongSongEditableField,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MusicalWorks';
          palletCall: {
            name: 'UpdateField';
            params: { middsId: H256; fieldData: MiddsSongSongEditableField };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     **/
    unregister: GenericTxCall<
      Rv,
      (middsId: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MusicalWorks';
          palletCall: {
            name: 'Unregister';
            params: { middsId: H256 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}
