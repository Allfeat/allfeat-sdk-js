// Generated by dedot cli

import type {
  GenericChainStorage,
  GenericStorageQuery,
  Callback,
  RpcVersion,
} from 'dedot/types';
import type {
  AccountId32,
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedBytes,
  BytesLike,
  Data,
  FixedU128,
} from 'dedot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  FrameSupportTokensMiscIdAmount,
  FrameSupportTokensMiscIdAmountRuntimeFreezeReason,
  SpConsensusBabeAppPublic,
  SpConsensusSlotsSlot,
  SpConsensusBabeDigestsNextConfigDescriptor,
  SpConsensusBabeDigestsPreDigest,
  SpConsensusBabeBabeEpochConfiguration,
  PalletImOnlineSr25519AppSr25519Public,
  MelodieRuntimePalletsSessionSessionKeys,
  SpCoreCryptoKeyTypeId,
  PalletGrandpaStoredState,
  PalletGrandpaStoredPendingChange,
  SpConsensusGrandpaAppPublic,
  SpAuthorityDiscoveryAppPublic,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  PalletIdentityAuthorityProperties,
  PalletSchedulerScheduled,
  PalletSchedulerRetryConfig,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletMultisigMultisig,
  PalletTransactionPaymentReleases,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PalletMiddsMiddsWrapper,
  PalletMiddsMiddsWrapperSong,
} from './types';

export interface ChainStorage<Rv extends RpcVersion>
  extends GenericChainStorage<Rv> {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => FrameSystemAccountInfo,
      AccountId32
    >;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<
      Rv,
      () => FrameSupportDispatchPerDispatchClass
    >;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<Rv, () => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<Rv, () => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<Rv, () => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<
      Rv,
      (arg: H256) => Array<[number, number]>,
      H256
    >;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemLastRuntimeUpgradeInfo | undefined
    >;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<Rv, () => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemCodeUpgradeAuthorization | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletBalancesAccountData,
      AccountId32
    >;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesBalanceLock>,
      AccountId32
    >;

    /**
     * Named reserves on some account balances.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesReserveData>,
      AccountId32
    >;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmount>,
      AccountId32
    >;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>> =} callback
     **/
    freezes: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Babe`'s storage queries
   **/
  babe: {
    /**
     * Current epoch index.
     *
     * @param {Callback<bigint> =} callback
     **/
    epochIndex: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Current epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<[SpConsensusBabeAppPublic, bigint]>
    >;

    /**
     * The slot at which the first epoch actually started. This is 0
     * until the first block of the chain.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    genesisSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * Current slot number.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * The epoch randomness for the *current* epoch.
     *
     * # Security
     *
     * This MUST NOT be used for gambling, as it can be influenced by a
     * malicious validator in the short term. It MAY be used in many
     * cryptographic protocols, however, so long as one remembers that this
     * (like everything else on-chain) it is public. For example, it can be
     * used where a number is needed that cannot have been chosen by an
     * adversary, for purposes such as public-coin zero-knowledge proofs.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    randomness: GenericStorageQuery<Rv, () => FixedBytes<32>>;

    /**
     * Pending epoch configuration change that will be applied when the next epoch is enacted.
     *
     * @param {Callback<SpConsensusBabeDigestsNextConfigDescriptor | undefined> =} callback
     **/
    pendingEpochConfigChange: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeDigestsNextConfigDescriptor | undefined
    >;

    /**
     * Next epoch randomness.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    nextRandomness: GenericStorageQuery<Rv, () => FixedBytes<32>>;

    /**
     * Next epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    nextAuthorities: GenericStorageQuery<
      Rv,
      () => Array<[SpConsensusBabeAppPublic, bigint]>
    >;

    /**
     * Randomness under construction.
     *
     * We make a trade-off between storage accesses and list length.
     * We store the under-construction randomness in segments of up to
     * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
     *
     * Once a segment reaches this length, we begin the next one.
     * We reset all segments and return to `0` at the beginning of every
     * epoch.
     *
     * @param {Callback<number> =} callback
     **/
    segmentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.
     *
     * @param {number} arg
     * @param {Callback<Array<FixedBytes<32>>> =} callback
     **/
    underConstruction: GenericStorageQuery<
      Rv,
      (arg: number) => Array<FixedBytes<32>>,
      number
    >;

    /**
     * Temporary value (cleared at block finalization) which is `Some`
     * if per-block initialization has already been called for current block.
     *
     * @param {Callback<SpConsensusBabeDigestsPreDigest | undefined | undefined> =} callback
     **/
    initialized: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeDigestsPreDigest | undefined | undefined
    >;

    /**
     * This field should always be populated during block processing unless
     * secondary plain slots are enabled (which don't contain a VRF output).
     *
     * It is set in `on_finalize`, before it will contain the value from the last block.
     *
     * @param {Callback<FixedBytes<32> | undefined> =} callback
     **/
    authorVrfRandomness: GenericStorageQuery<
      Rv,
      () => FixedBytes<32> | undefined
    >;

    /**
     * The block numbers when the last and current epoch have started, respectively `N-1` and
     * `N`.
     * NOTE: We track this is in order to annotate the block number when a given pool of
     * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
     * slots, which may be skipped, the block numbers may not line up with the slot numbers.
     *
     * @param {Callback<[number, number]> =} callback
     **/
    epochStart: GenericStorageQuery<Rv, () => [number, number]>;

    /**
     * How late the current block is compared to its parent.
     *
     * This entry is populated as part of block execution and is cleaned up
     * on block finalization. Querying this storage entry outside of block
     * execution context should always yield zero.
     *
     * @param {Callback<number> =} callback
     **/
    lateness: GenericStorageQuery<Rv, () => number>;

    /**
     * The configuration for the current epoch. Should never be `None` as it is initialized in
     * genesis.
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    epochConfig: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeBabeEpochConfiguration | undefined
    >;

    /**
     * The configuration for the next epoch, `None` if the config will not change
     * (you can fallback to `EpochConfig` instead in that case).
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    nextEpochConfig: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeBabeEpochConfiguration | undefined
    >;

    /**
     * A list of the last 100 skipped epochs and the corresponding session index
     * when the epoch was skipped.
     *
     * This is only used for validating equivocation proofs. An equivocation proof
     * must contains a key-ownership proof for a given session, therefore we need a
     * way to tie together sessions and epoch indices, i.e. we need to validate that
     * a validator was the owner of a given key on a given session, and what the
     * active epoch index was during that session.
     *
     * @param {Callback<Array<[bigint, number]>> =} callback
     **/
    skippedEpochs: GenericStorageQuery<Rv, () => Array<[bigint, number]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ImOnline`'s storage queries
   **/
  imOnline: {
    /**
     * The block number after which it's ok to send heartbeats in the current
     * session.
     *
     * At the beginning of each session we set this to a value that should fall
     * roughly in the middle of the session duration. The idea is to first wait for
     * the validators to produce a block in the current session, so that the
     * heartbeat later on will not be necessary.
     *
     * This value will only be used as a fallback if we fail to get a proper session
     * progress estimate from `NextSessionRotation`, as those estimates should be
     * more accurate then the value we calculate for `HeartbeatAfter`.
     *
     * @param {Callback<number> =} callback
     **/
    heartbeatAfter: GenericStorageQuery<Rv, () => number>;

    /**
     * The current set of keys that may issue a heartbeat.
     *
     * @param {Callback<Array<PalletImOnlineSr25519AppSr25519Public>> =} callback
     **/
    keys: GenericStorageQuery<
      Rv,
      () => Array<PalletImOnlineSr25519AppSr25519Public>
    >;

    /**
     * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`.
     *
     * @param {[number, number]} arg
     * @param {Callback<boolean | undefined> =} callback
     **/
    receivedHeartbeats: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => boolean | undefined,
      [number, number]
    >;

    /**
     * For each session index, we keep a mapping of `ValidatorId<T>` to the
     * number of blocks authored by the given authority.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number> =} callback
     **/
    authoredBlocks: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => number,
      [number, AccountId32]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ValidatorSet`'s storage queries
   **/
  validatorSet: {
    /**
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    offlineValidators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, MelodieRuntimePalletsSessionSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<
      Rv,
      () => Array<[AccountId32, MelodieRuntimePalletsSessionSessionKeys]>
    >;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<MelodieRuntimePalletsSessionSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => MelodieRuntimePalletsSessionSessionKeys | undefined,
      AccountId32
    >;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      Rv,
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Grandpa`'s storage queries
   **/
  grandpa: {
    /**
     * State of the current authority set.
     *
     * @param {Callback<PalletGrandpaStoredState> =} callback
     **/
    state: GenericStorageQuery<Rv, () => PalletGrandpaStoredState>;

    /**
     * Pending change: (signaled at, scheduled change).
     *
     * @param {Callback<PalletGrandpaStoredPendingChange | undefined> =} callback
     **/
    pendingChange: GenericStorageQuery<
      Rv,
      () => PalletGrandpaStoredPendingChange | undefined
    >;

    /**
     * next block number where we can force a change.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextForced: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * `true` if we are currently stalled.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    stalled: GenericStorageQuery<Rv, () => [number, number] | undefined>;

    /**
     * The number of changes (both in terms of keys and underlying economic responsibilities)
     * in the "set" of Grandpa validators from genesis.
     *
     * @param {Callback<bigint> =} callback
     **/
    currentSetId: GenericStorageQuery<Rv, () => bigint>;

    /**
     * A mapping from grandpa set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `SetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<
      Rv,
      (arg: bigint) => number | undefined,
      bigint
    >;

    /**
     * The current list of authorities.
     *
     * @param {Callback<Array<[SpConsensusGrandpaAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<[SpConsensusGrandpaAppPublic, bigint]>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AuthorityDiscovery`'s storage queries
   **/
  authorityDiscovery: {
    /**
     * Keys of the current authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    keys: GenericStorageQuery<Rv, () => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Keys of the next authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    nextKeys: GenericStorageQuery<
      Rv,
      () => Array<SpAuthorityDiscoveryAppPublic>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Identity`'s storage queries
   **/
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account. First item is the
     * registration, second is the account's primary username.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[PalletIdentityRegistration, Bytes | undefined] | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => [PalletIdentityRegistration, Bytes | undefined] | undefined,
      AccountId32
    >;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[AccountId32, Data] | undefined> =} callback
     **/
    superOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [AccountId32, Data] | undefined,
      AccountId32
    >;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, Array<AccountId32>]> =} callback
     **/
    subsOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [bigint, Array<AccountId32>],
      AccountId32
    >;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     *
     * @param {Callback<Array<PalletIdentityRegistrarInfo | undefined>> =} callback
     **/
    registrars: GenericStorageQuery<
      Rv,
      () => Array<PalletIdentityRegistrarInfo | undefined>
    >;

    /**
     * A map of the accounts who are authorized to grant usernames.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletIdentityAuthorityProperties | undefined> =} callback
     **/
    usernameAuthorities: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletIdentityAuthorityProperties | undefined,
      AccountId32
    >;

    /**
     * Reverse lookup from `username` to the `AccountId` that has registered it. The value should
     * be a key in the `IdentityOf` map, but it may not if the user has cleared their identity.
     *
     * Multiple usernames may map to the same `AccountId`, but `IdentityOf` will only map to one
     * primary username.
     *
     * @param {BytesLike} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    accountOfUsername: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => AccountId32 | undefined,
      Bytes
    >;

    /**
     * Usernames that an authority has granted, but that the account controller has not confirmed
     * that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
     * because they are a pure proxy, multisig, etc. In order to confirm it, they should call
     * [`Call::accept_username`].
     *
     * First tuple item is the account and second is the acceptance deadline.
     *
     * @param {BytesLike} arg
     * @param {Callback<[AccountId32, number] | undefined> =} callback
     **/
    pendingUsernames: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => [AccountId32, number] | undefined,
      Bytes
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<
      Rv,
      (arg: number) => Array<PalletSchedulerScheduled | undefined>,
      number
    >;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletSchedulerRetryConfig | undefined,
      [number, number]
    >;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<
      Rv,
      (arg: FixedBytes<32>) => [number, number] | undefined,
      FixedBytes<32>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Sudo`'s storage queries
   **/
  sudo: {
    /**
     * The `AccountId` of the sudo key.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    key: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint],
      AccountId32
    >;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint],
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      Rv,
      (
        arg: [AccountId32Like, FixedBytes<32>],
      ) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<
      Rv,
      () => PalletTransactionPaymentReleases
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Historical`'s storage queries
   **/
  historical: {
    /**
     * Mapping from historical session indices to session-data root hash and validator count.
     *
     * @param {number} arg
     * @param {Callback<[H256, number] | undefined> =} callback
     **/
    historicalSessions: GenericStorageQuery<
      Rv,
      (arg: number) => [H256, number] | undefined,
      number
    >;

    /**
     * The range of historical sessions we store. [first, last)
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    storedRange: GenericStorageQuery<Rv, () => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageOldRequestStatus | undefined,
      H256
    >;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageRequestStatus | undefined,
      H256
    >;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<
      Rv,
      (arg: [H256, number]) => Bytes | undefined,
      [H256, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Stakeholders`'s storage queries
   **/
  stakeholders: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<PalletMiddsMiddsWrapper | undefined> =} callback
     **/
    pendingMidds: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletMiddsMiddsWrapper | undefined,
      H256
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MusicalWorks`'s storage queries
   **/
  musicalWorks: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<PalletMiddsMiddsWrapperSong | undefined> =} callback
     **/
    pendingMidds: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletMiddsMiddsWrapperSong | undefined,
      H256
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Mmr`'s storage queries
   **/
  mmr: {
    /**
     * Latest MMR Root hash.
     *
     * @param {Callback<H256> =} callback
     **/
    rootHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Current size of the MMR (number of leaves).
     *
     * @param {Callback<bigint> =} callback
     **/
    numberOfLeaves: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Hashes of the nodes in the MMR.
     *
     * Note this collection only contains MMR peaks, the inner nodes (and leaves)
     * are pruned and only stored in the Offchain DB.
     *
     * @param {bigint} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    nodes: GenericStorageQuery<Rv, (arg: bigint) => H256 | undefined, bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
}
