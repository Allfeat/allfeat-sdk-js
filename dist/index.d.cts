import { WsProvider, DedotClient } from 'dedot';
import { Bytes, H256, Percent, Phase, DispatchInfo, DispatchError, AccountId32, FixedBytes, Result, Header, MultiAddressLike, AccountId32Like, Data, BytesLike, RuntimeVersion, Digest, FixedU128, Option, OpaqueMetadata, OpaqueExtrinsicLike, ApplyExtrinsicResult, Block, InherentData, CheckInherentsResult, OpaqueExtrinsic, TransactionSource, BlockHash, TransactionValidity, SetId, OpaqueKeyOwnershipProof, AuthorityList, GrandpaEquivocationProof, BabeConfiguration, BabeEpoch, Slot, BabeEquivocationProof, Nonce, RuntimeDispatchInfo, FeeDetails, Balance, Weight, RawBytesLike, KeyTypeId, Text, Extrinsic } from 'dedot/codecs';
import { RpcVersion, GenericChainConsts, GenericChainStorage, GenericStorageQuery, GenericJsonRpcApis, GenericChainErrors, GenericPalletError, GenericChainEvents, GenericPalletEvent, GenericRuntimeApis, GenericRuntimeApiMethod, GenericChainTx, GenericTxCall, IRuntimeTxCall, RpcV2, ISubmittableExtrinsic, ISubmittableResult, ISubmittableExtrinsicLegacy, RpcLegacy, GenericSubstrateApi, Callback } from 'dedot/types';
import { JsonRpcApis } from 'dedot/types/json-rpc';
import { KeyringPair } from '@polkadot/keyring/types';

// Generated by dedot cli



type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

type PalletBalancesExtraFlags = bigint;

type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

type FrameSystemEventRecord = {
  phase: Phase;
  event: MelodieRuntimeRuntimeEvent;
  topics: Array<H256>;
};

type MelodieRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'ImOnline'; palletEvent: PalletImOnlineEvent }
  | { pallet: 'ValidatorSet'; palletEvent: SubstrateValidatorSetEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'Grandpa'; palletEvent: PalletGrandpaEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Sudo'; palletEvent: PalletSudoEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'Stakeholders'; palletEvent: PalletMiddsEvent }
  | { pallet: 'MusicalWorks'; palletEvent: PalletMiddsEvent };

/**
 * Event for the System pallet.
 **/
type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | {
      name: 'ExtrinsicFailed';
      data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo };
    }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } }
  /**
   * A [`Task`] has started executing
   **/
  | { name: 'TaskStarted'; data: { task: MelodieRuntimeRuntimeTask } }
  /**
   * A [`Task`] has finished executing.
   **/
  | { name: 'TaskCompleted'; data: { task: MelodieRuntimeRuntimeTask } }
  /**
   * A [`Task`] failed during execution.
   **/
  | {
      name: 'TaskFailed';
      data: { task: MelodieRuntimeRuntimeTask; err: DispatchError };
    }
  /**
   * An upgrade was authorized.
   **/
  | {
      name: 'UpgradeAuthorized';
      data: { codeHash: H256; checkVersion: boolean };
    };

type MelodieRuntimeRuntimeTask = null;

/**
 * The `Event` enum of this pallet
 **/
type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | {
      name: 'Transfer';
      data: { from: AccountId32; to: AccountId32; amount: bigint };
    }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: 'TotalIssuanceForced'; data: { old: bigint; new: bigint } };

type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
type PalletImOnlineEvent =
  /**
   * A new heartbeat was received from `AuthorityId`.
   **/
  | {
      name: 'HeartbeatReceived';
      data: { authorityId: PalletImOnlineSr25519AppSr25519Public };
    }
  /**
   * At the end of the session, no offence was committed.
   **/
  | { name: 'AllGood' }
  /**
   * At the end of the session, at least one validator was found to be offline.
   **/
  | {
      name: 'SomeOffline';
      data: { offline: Array<[AccountId32, AccountId32]> };
    };

type PalletImOnlineSr25519AppSr25519Public = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
type SubstrateValidatorSetEvent =
  /**
   * New validator addition initiated. Effective in ~2 sessions.
   **/
  | { name: 'ValidatorAdditionInitiated'; data: AccountId32 }
  /**
   * Validator removal initiated. Effective in ~2 sessions.
   **/
  | { name: 'ValidatorRemovalInitiated'; data: AccountId32 };

/**
 * The `Event` enum of this pallet
 **/
type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
type PalletGrandpaEvent =
  /**
   * New authority set has been applied.
   **/
  | {
      name: 'NewAuthorities';
      data: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> };
    }
  /**
   * Current authority set has been paused.
   **/
  | { name: 'Paused' }
  /**
   * Current authority set has been resumed.
   **/
  | { name: 'Resumed' };

type SpConsensusGrandpaAppPublic = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | {
      name: 'JudgementRequested';
      data: { who: AccountId32; registrarIndex: number };
    }
  /**
   * A judgement request was retracted.
   **/
  | {
      name: 'JudgementUnrequested';
      data: { who: AccountId32; registrarIndex: number };
    }
  /**
   * A judgement was given by a registrar.
   **/
  | {
      name: 'JudgementGiven';
      data: { target: AccountId32; registrarIndex: number };
    }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | {
      name: 'SubIdentityAdded';
      data: { sub: AccountId32; main: AccountId32; deposit: bigint };
    }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | {
      name: 'SubIdentityRemoved';
      data: { sub: AccountId32; main: AccountId32; deposit: bigint };
    }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | {
      name: 'SubIdentityRevoked';
      data: { sub: AccountId32; main: AccountId32; deposit: bigint };
    }
  /**
   * A username authority was added.
   **/
  | { name: 'AuthorityAdded'; data: { authority: AccountId32 } }
  /**
   * A username authority was removed.
   **/
  | { name: 'AuthorityRemoved'; data: { authority: AccountId32 } }
  /**
   * A username was set for `who`.
   **/
  | { name: 'UsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A username was queued, but `who` must accept it prior to `expiration`.
   **/
  | {
      name: 'UsernameQueued';
      data: { who: AccountId32; username: Bytes; expiration: number };
    }
  /**
   * A queued username passed its expiration without being claimed and was removed.
   **/
  | { name: 'PreapprovalExpired'; data: { whose: AccountId32 } }
  /**
   * A username was set as a primary and can be looked up from `who`.
   **/
  | { name: 'PrimaryUsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A dangling username (as in, a username corresponding to an account that has removed its
   * identity) has been removed.
   **/
  | {
      name: 'DanglingUsernameRemoved';
      data: { who: AccountId32; username: Bytes };
    };

/**
 * Events type.
 **/
type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: 'RetrySet';
      data: {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        period: number;
        retries: number;
      };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | {
      name: 'RetryCancelled';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | {
      name: 'CallUnavailable';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | {
      name: 'PeriodicFailed';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | {
      name: 'RetryFailed';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | {
      name: 'PermanentlyOverweight';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    };

/**
 * The `Event` enum of this pallet
 **/
type PalletSudoEvent =
  /**
   * A sudo call just took place.
   **/
  | {
      name: 'Sudid';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    }
  /**
   * The sudo key has been updated.
   **/
  | {
      name: 'KeyChanged';
      data: {
        /**
         * The old sudo key (if one was previously set).
         **/
        old?: AccountId32 | undefined;

        /**
         * The new sudo key (if one was set).
         **/
        new: AccountId32;
      };
    }
  /**
   * The key was permanently removed.
   **/
  | { name: 'KeyRemoved' }
  /**
   * A [sudo_as](Pallet::sudo_as) call just took place.
   **/
  | {
      name: 'SudoAsDone';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | {
      name: 'Announced';
      data: { real: AccountId32; proxy: AccountId32; callHash: H256 };
    }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        delay: number;
      };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        delay: number;
      };
    };

type MelodieRuntimePalletsProxyProxyType = 'Any' | 'NonTransfer';

/**
 * The `Event` enum of this pallet
 **/
type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | {
      name: 'NewMultisig';
      data: {
        approving: AccountId32;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  {
    name: 'TransactionFeePaid';
    data: { who: AccountId32; actualFee: bigint; tip: bigint };
  };

/**
 * The `Event` enum of this pallet
 **/
type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
type PalletMiddsEvent =
  | {
      name: 'MiddsRegistered';
      data: { provider: AccountId32; hashId: H256; dataColateral: bigint };
    }
  | { name: 'MiddsUpdated'; data: { hashId: H256 } }
  | { name: 'MiddsUnregistered'; data: { hashId: H256 } };

type FrameSystemLastRuntimeUpgradeInfo = {
  specVersion: number;
  specName: string;
};

type FrameSystemCodeUpgradeAuthorization = {
  codeHash: H256;
  checkVersion: boolean;
};

type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }
  | { name: 'DoTask'; params: { task: MelodieRuntimeRuntimeTask } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: BytesLike } };

type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

type FrameSystemLimitsBlockLength = {
  max: FrameSupportDispatchPerDispatchClassU32;
};

type FrameSupportDispatchPerDispatchClassU32 = {
  normal: number;
  operational: number;
  mandatory: number;
};

type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

type PalletBalancesBalanceLock = {
  id: FixedBytes<8>;
  amount: bigint;
  reasons: PalletBalancesReasons;
};

type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

type FrameSupportTokensMiscIdAmount = {
  id: MelodieRuntimeRuntimeHoldReason;
  amount: bigint;
};

type MelodieRuntimeRuntimeHoldReason =
  | { type: 'Preimage'; value: PalletPreimageHoldReason }
  | { type: 'Stakeholders'; value: PalletMiddsHoldReason }
  | { type: 'MusicalWorks'; value: PalletMiddsHoldReason };

type PalletPreimageHoldReason = 'Preimage';

type PalletMiddsHoldReason = 'MiddsRegistration';

type FrameSupportTokensMiscIdAmountRuntimeFreezeReason = {
  id: MelodieRuntimeRuntimeFreezeReason;
  amount: bigint;
};

type MelodieRuntimeRuntimeFreezeReason = null;

type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | {
      name: 'TransferAllowDeath';
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | {
      name: 'ForceTransfer';
      params: {
        source: MultiAddressLike;
        dest: MultiAddressLike;
        value: bigint;
      };
    }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | {
      name: 'TransferKeepAlive';
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | {
      name: 'TransferAll';
      params: { dest: MultiAddressLike; keepAlive: boolean };
    }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | {
      name: 'ForceUnreserve';
      params: { who: MultiAddressLike; amount: bigint };
    }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | {
      name: 'ForceSetBalance';
      params: { who: MultiAddressLike; newFree: bigint };
    }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | {
      name: 'ForceAdjustTotalIssuance';
      params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
    }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: 'Burn'; params: { value: bigint; keepAlive: boolean } };

type PalletBalancesAdjustmentDirection = 'Increase' | 'Decrease';

type SpConsensusBabeAppPublic = FixedBytes<32>;

type SpConsensusSlotsSlot = bigint;

type SpConsensusBabeDigestsNextConfigDescriptor = {
  type: 'V1';
  value: { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };
};

type SpConsensusBabeAllowedSlots =
  | 'PrimarySlots'
  | 'PrimaryAndSecondaryPlainSlots'
  | 'PrimaryAndSecondaryVRFSlots';

type SpConsensusBabeDigestsPreDigest =
  | { type: 'Primary'; value: SpConsensusBabeDigestsPrimaryPreDigest }
  | {
      type: 'SecondaryPlain';
      value: SpConsensusBabeDigestsSecondaryPlainPreDigest;
    }
  | {
      type: 'SecondaryVRF';
      value: SpConsensusBabeDigestsSecondaryVRFPreDigest;
    };

type SpConsensusBabeDigestsPrimaryPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

type SpCoreSr25519VrfVrfSignature = {
  preOutput: FixedBytes<32>;
  proof: FixedBytes<64>;
};

type SpConsensusBabeDigestsSecondaryPlainPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
};

type SpConsensusBabeDigestsSecondaryVRFPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

type SpConsensusBabeBabeEpochConfiguration = {
  c: [bigint, bigint];
  allowedSlots: SpConsensusBabeAllowedSlots;
};

type PalletBabeCallLike =
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: {
        equivocationProof: SpConsensusSlotsEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: {
        equivocationProof: SpConsensusSlotsEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   **/
  | {
      name: 'PlanConfigChange';
      params: { config: SpConsensusBabeDigestsNextConfigDescriptor };
    };

type SpConsensusSlotsEquivocationProof = {
  offender: SpConsensusBabeAppPublic;
  slot: SpConsensusSlotsSlot;
  firstHeader: Header;
  secondHeader: Header;
};

type SpSessionMembershipProof = {
  session: number;
  trieNodes: Array<Bytes>;
  validatorCount: number;
};

type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

type PalletImOnlineCallLike =
  /**
   * ## Complexity:
   * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
   * - `O(K)`: decoding of length `K`
   **/
  {
    name: 'Heartbeat';
    params: {
      heartbeat: PalletImOnlineHeartbeat;
      signature: PalletImOnlineSr25519AppSr25519Signature;
    };
  };

type PalletImOnlineHeartbeat = {
  blockNumber: number;
  sessionIndex: number;
  authorityIndex: number;
  validatorsLen: number;
};

type PalletImOnlineSr25519AppSr25519Signature = FixedBytes<64>;

type SubstrateValidatorSetCallLike =
  /**
   * Add a new validator.
   *
   * New validator's session keys should be set in Session pallet before
   * calling this.
   *
   * The origin can be configured using the `AddRemoveOrigin` type in the
   * host runtime. Can also be set to sudo/root.
   **/
  | { name: 'AddValidator'; params: { validatorId: AccountId32Like } }
  /**
   * Remove a validator.
   *
   * The origin can be configured using the `AddRemoveOrigin` type in the
   * host runtime. Can also be set to sudo/root.
   **/
  | { name: 'RemoveValidator'; params: { validatorId: AccountId32Like } };

type MelodieRuntimePalletsSessionSessionKeys = {
  grandpa: SpConsensusGrandpaAppPublic;
  babe: SpConsensusBabeAppPublic;
  imOnline: PalletImOnlineSr25519AppSr25519Public;
  authorityDiscovery: SpAuthorityDiscoveryAppPublic;
};

type SpAuthorityDiscoveryAppPublic = FixedBytes<32>;

type SpCoreCryptoKeyTypeId = FixedBytes<4>;

type PalletSessionCallLike =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | {
      name: 'SetKeys';
      params: {
        keys: MelodieRuntimePalletsSessionSessionKeys;
        proof: BytesLike;
      };
    }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

type PalletGrandpaStoredState =
  | { type: 'Live' }
  | { type: 'PendingPause'; value: { scheduledAt: number; delay: number } }
  | { type: 'Paused' }
  | { type: 'PendingResume'; value: { scheduledAt: number; delay: number } };

type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

type PalletGrandpaCallLike =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | {
      name: 'NoteStalled';
      params: { delay: number; bestFinalizedBlockNumber: number };
    };

type SpConsensusGrandpaEquivocationProof = {
  setId: bigint;
  equivocation: SpConsensusGrandpaEquivocation;
};

type SpConsensusGrandpaEquivocation =
  | { type: 'Prevote'; value: FinalityGrandpaEquivocation }
  | { type: 'Precommit'; value: FinalityGrandpaEquivocationPrecommit };

type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

type SpConsensusGrandpaAppSignature = FixedBytes<64>;

type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

type FinalityGrandpaPrecommit = {
  targetHash: H256;
  targetNumber: number;
};

type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<MelodieRuntimeRuntimeCallLike> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: 'AsDerivative';
      params: { index: number; call: MelodieRuntimeRuntimeCallLike };
    }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: 'BatchAll';
      params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
    }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: 'DispatchAs';
      params: {
        asOrigin: MelodieRuntimeOriginCaller;
        call: MelodieRuntimeRuntimeCallLike;
      };
    }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: 'ForceBatch';
      params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
    }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | {
      name: 'WithWeight';
      params: {
        call: MelodieRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    };

type MelodieRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'Babe'; palletCall: PalletBabeCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'ImOnline'; palletCall: PalletImOnlineCallLike }
  | { pallet: 'ValidatorSet'; palletCall: SubstrateValidatorSetCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'Grandpa'; palletCall: PalletGrandpaCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'Sudo'; palletCall: PalletSudoCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCallLike }
  | { pallet: 'Stakeholders'; palletCall: PalletMiddsCallLike }
  | { pallet: 'MusicalWorks'; palletCall: PalletMiddsCallLike002 };

type PalletIdentityCallLike =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddressLike } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: SharedRuntimeIdentityIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Registrars::<T>::get().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddressLike } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: {
        regIndex: number;
        target: MultiAddressLike;
        judgement: PalletIdentityJudgement;
        identity: H256;
      };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddressLike } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddressLike } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | {
      name: 'AddUsernameAuthority';
      params: {
        authority: MultiAddressLike;
        suffix: BytesLike;
        allocation: number;
      };
    }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: MultiAddressLike } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: {
        who: MultiAddressLike;
        username: BytesLike;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: BytesLike } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: BytesLike } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: BytesLike } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: BytesLike } };

type SharedRuntimeIdentityIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  matrix: Data;
  email: Data;
  twitter: Data;
  instagram: Data;
  youtube: Data;
  tiktok: Data;
  discord: Data;
  telegram: Data;
};

type PalletIdentityJudgement =
  | { type: 'Unknown' }
  | { type: 'FeePaid'; value: bigint }
  | { type: 'Reasonable' }
  | { type: 'KnownGood' }
  | { type: 'OutOfDate' }
  | { type: 'LowQuality' }
  | { type: 'Erroneous' };

type SpRuntimeMultiSignature =
  | { type: 'Ed25519'; value: FixedBytes<64> }
  | { type: 'Sr25519'; value: FixedBytes<64> }
  | { type: 'Ecdsa'; value: FixedBytes<65> };

type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MelodieRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MelodieRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MelodieRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MelodieRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: 'SetRetry';
      params: { task: [number, number]; retries: number; period: number };
    }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: 'SetRetryNamed';
      params: { id: FixedBytes<32>; retries: number; period: number };
    }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

type PalletSudoCallLike =
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   **/
  | { name: 'Sudo'; params: { call: MelodieRuntimeRuntimeCallLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * Sudo user to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: 'SudoUncheckedWeight';
      params: {
        call: MelodieRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
   * key.
   **/
  | { name: 'SetKey'; params: { new: MultiAddressLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Signed` origin from
   * a given account.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: 'SudoAs';
      params: { who: MultiAddressLike; call: MelodieRuntimeRuntimeCallLike };
    }
  /**
   * Permanently removes the sudo key.
   *
   * **This cannot be un-done.**
   **/
  | { name: 'RemoveKey' };

type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddressLike;
        forceProxyType?: MelodieRuntimePalletsProxyProxyType | undefined;
        call: MelodieRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | {
      name: 'AddProxy';
      params: {
        delegate: MultiAddressLike;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        delay: number;
      };
    }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | {
      name: 'RemoveProxy';
      params: {
        delegate: MultiAddressLike;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        delay: number;
      };
    }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | {
      name: 'CreatePure';
      params: {
        proxyType: MelodieRuntimePalletsProxyProxyType;
        delay: number;
        index: number;
      };
    }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddressLike;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | {
      name: 'RemoveAnnouncement';
      params: { real: MultiAddressLike; callHash: H256 };
    }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | {
      name: 'RejectAnnouncement';
      params: { delegate: MultiAddressLike; callHash: H256 };
    }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: MelodieRuntimePalletsProxyProxyType | undefined;
        call: MelodieRuntimeRuntimeCallLike;
      };
    };

type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: 'AsMultiThreshold1';
      params: {
        otherSignatories: Array<AccountId32Like>;
        call: MelodieRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: MelodieRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

type PalletMiddsCallLike =
  | { name: 'Register'; params: { midds: MiddsStakeholderStakeholder } }
  | {
      name: 'UpdateField';
      params: {
        middsId: H256;
        fieldData: MiddsStakeholderEditableStakeholderField;
      };
    }
  | { name: 'Unregister'; params: { middsId: H256 } };

type MiddsStakeholderStakeholder = {
  ipi?: AllfeatSupportIpiIpiNameNumber | undefined;
  firstName?: Bytes | undefined;
  lastName?: Bytes | undefined;
  nickname?: Bytes | undefined;
};

type AllfeatSupportIpiIpiNameNumber = bigint;

type MiddsStakeholderEditableStakeholderField =
  | { type: 'IpiBase'; value?: AllfeatSupportIpiIpiNameNumber | undefined }
  | { type: 'FirstName'; value?: Bytes | undefined }
  | { type: 'LastName'; value?: Bytes | undefined }
  | { type: 'Nickname'; value?: Bytes | undefined };

type PalletMiddsCallLike002 =
  | { name: 'Register'; params: { midds: MiddsSongSong } }
  | {
      name: 'UpdateField';
      params: { middsId: H256; fieldData: MiddsSongSongEditableField };
    }
  | { name: 'Unregister'; params: { middsId: H256 } };

type MiddsSongSong = {
  iswc?: AllfeatSupportIswc | undefined;
  title?: Bytes | undefined;
  duration?: number | undefined;
  type?: AllfeatSupportSongType | undefined;
  shares?: Array<MiddsSongShare> | undefined;
};

type AllfeatSupportIswc = {
  group1: number;
  group2: number;
  group3: number;
  checkDigit: number;
};

type AllfeatSupportSongType = 'Instrumental' | 'Song';

type MiddsSongShare = {
  stakeholderId: H256;
  shareInfo: MiddsSongShareInfo;
};

type MiddsSongShareInfo = {
  role: MiddsSongRole;
  performanceShare: Percent;
  mechanicalShare: Percent;
};

type MiddsSongRole =
  | 'A'
  | 'Ad'
  | 'Am'
  | 'Ar'
  | 'C'
  | 'Ca'
  | 'E'
  | 'Es'
  | 'Pa'
  | 'Pr'
  | 'Sa'
  | 'Se'
  | 'Sr'
  | 'Tr';

type MiddsSongSongEditableField =
  | { type: 'Iswc'; value?: AllfeatSupportIswc | undefined }
  | { type: 'Title'; value?: Bytes | undefined }
  | { type: 'Duration'; value?: number | undefined }
  | { type: 'Type'; value?: AllfeatSupportSongType | undefined }
  | { type: 'Shares'; value: MiddsSongSharesEditAction };

type MiddsSongSharesEditAction =
  | { type: 'Add'; value: MiddsSongShare }
  | { type: 'Remove'; value: number };

type MelodieRuntimeOriginCaller =
  | { type: 'System'; value: FrameSupportDispatchRawOrigin }
  | { type: 'Void'; value: SpCoreVoid };

type FrameSupportDispatchRawOrigin =
  | { type: 'Root' }
  | { type: 'Signed'; value: AccountId32 }
  | { type: 'None' };

type SpCoreVoid = null;

type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: SharedRuntimeIdentityIdentityInfo;
};

type PalletIdentityRegistrarInfo = {
  account: AccountId32;
  fee: bigint;
  fields: bigint;
};

type PalletIdentityAuthorityProperties = {
  suffix: Bytes;
  allocation: number;
};

type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: MelodieRuntimeOriginCaller;
};

type FrameSupportPreimagesBounded =
  | { type: 'Legacy'; value: { hash: H256 } }
  | { type: 'Inline'; value: Bytes }
  | { type: 'Lookup'; value: { hash: H256; len: number } };

type PalletSchedulerRetryConfig = {
  totalRetries: number;
  remaining: number;
  period: number;
};

type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: MelodieRuntimePalletsProxyProxyType;
  delay: number;
};

type PalletProxyAnnouncement = {
  real: AccountId32;
  callHash: H256;
  height: number;
};

type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

type PalletPreimageOldRequestStatus =
  | {
      type: 'Unrequested';
      value: { deposit: [AccountId32, bigint]; len: number };
    }
  | {
      type: 'Requested';
      value: {
        deposit?: [AccountId32, bigint] | undefined;
        count: number;
        len?: number | undefined;
      };
    };

type PalletPreimageRequestStatus =
  | {
      type: 'Unrequested';
      value: {
        ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration];
        len: number;
      };
    }
  | {
      type: 'Requested';
      value: {
        maybeTicket?:
          | [AccountId32, FrameSupportTokensFungibleHoldConsideration]
          | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

type FrameSupportTokensFungibleHoldConsideration = bigint;

type PalletMiddsMiddsWrapper = {
  base: PalletMiddsBaseInfos;
  midds: MiddsStakeholderStakeholder;
};

type PalletMiddsBaseInfos = {
  provider: AccountId32;
  registeredAt: number;
};

type FrameSupportPalletId = FixedBytes<8>;

type PalletMiddsMiddsWrapperSong = {
  base: PalletMiddsBaseInfos;
  midds: MiddsSongSong;
};

// Generated by dedot cli



interface ChainConsts<Rv extends RpcVersion>
  extends GenericChainConsts<Rv> {
  /**
   * Pallet `System`'s constants
   **/
  system: {
    /**
     * Block & extrinsics weights: base values and limits.
     **/
    blockWeights: FrameSystemLimitsBlockWeights;

    /**
     * The maximum length of a block (in bytes).
     **/
    blockLength: FrameSystemLimitsBlockLength;

    /**
     * Maximum number of block number to block hash mappings to keep (oldest pruned first).
     **/
    blockHashCount: number;

    /**
     * The weight of runtime database operations the runtime can invoke.
     **/
    dbWeight: SpWeightsRuntimeDbWeight;

    /**
     * Get the chain's in-code version.
     **/
    version: RuntimeVersion;

    /**
     * The designated SS58 prefix of this chain.
     *
     * This replaces the "ss58Format" property declared in the chain spec. Reason is
     * that the runtime should know about the prefix in order to make use of it as
     * an identifier of the chain.
     **/
    ss58Prefix: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Balances`'s constants
   **/
  balances: {
    /**
     * The minimum amount required to keep an account open. MUST BE GREATER THAN ZERO!
     *
     * If you *really* need it to be zero, you can enable the feature `insecure_zero_ed` for
     * this pallet. However, you do so at your own risk: this will open up a major DoS vector.
     * In case you have multiple sources of provider references, you may also get unexpected
     * behaviour if you set this to zero.
     *
     * Bottom line: Do yourself a favour and make it at least one!
     **/
    existentialDeposit: bigint;

    /**
     * The maximum number of locks that should exist on an account.
     * Not strictly enforced, but used for weight estimation.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     **/
    maxLocks: number;

    /**
     * The maximum number of named reserves that can exist on an account.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     **/
    maxReserves: number;

    /**
     * The maximum number of individual freeze locks that can exist on an account at any time.
     **/
    maxFreezes: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Babe`'s constants
   **/
  babe: {
    /**
     * The amount of time, in slots, that each epoch should last.
     * NOTE: Currently it is not possible to change the epoch duration after
     * the chain has started. Attempting to do so will brick block production.
     **/
    epochDuration: bigint;

    /**
     * The expected average block time at which BABE should be creating
     * blocks. Since BABE is probabilistic it is not trivial to figure out
     * what the expected average block time should be based on the slot
     * duration and the security parameter `c` (where `1 - c` represents
     * the probability of a slot being empty).
     **/
    expectedBlockTime: bigint;

    /**
     * Max number of authorities allowed
     **/
    maxAuthorities: number;

    /**
     * The maximum number of nominators for each validator.
     **/
    maxNominators: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Timestamp`'s constants
   **/
  timestamp: {
    /**
     * The minimum period between blocks.
     *
     * Be aware that this is different to the *expected* period that the block production
     * apparatus provides. Your chosen consensus system will generally work with this to
     * determine a sensible block time. For example, in the Aura pallet it will be double this
     * period on default settings.
     **/
    minimumPeriod: bigint;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `ImOnline`'s constants
   **/
  imOnline: {
    /**
     * A configuration for base priority of unsigned transactions.
     *
     * This is exposed so that it can be tuned for particular runtime, when
     * multiple pallets send unsigned transactions.
     **/
    unsignedPriority: bigint;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Authorship`'s constants
   **/
  authorship: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `ValidatorSet`'s constants
   **/
  validatorSet: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Session`'s constants
   **/
  session: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Grandpa`'s constants
   **/
  grandpa: {
    /**
     * Max Authorities in use
     **/
    maxAuthorities: number;

    /**
     * The maximum number of nominators for each validator.
     **/
    maxNominators: number;

    /**
     * The maximum number of entries to keep in the set id to session index mapping.
     *
     * Since the `SetIdSession` map is only used for validating equivocations this
     * value should relate to the bonding duration of whatever staking system is
     * being used (if any). If equivocation handling is not enabled then this value
     * can be zero.
     **/
    maxSetIdSessionEntries: bigint;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `AuthorityDiscovery`'s constants
   **/
  authorityDiscovery: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Utility`'s constants
   **/
  utility: {
    /**
     * The limit on the number of batched calls.
     **/
    batchedCallsLimit: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Identity`'s constants
   **/
  identity: {
    /**
     * The amount held on deposit for a registered identity.
     **/
    basicDeposit: bigint;

    /**
     * The amount held on deposit per encoded byte for a registered identity.
     **/
    byteDeposit: bigint;

    /**
     * The amount held on deposit for a registered subaccount. This should account for the fact
     * that one storage item's value will increase by the size of an account ID, and there will
     * be another trie item whose value is the size of an account ID plus 32 bytes.
     **/
    subAccountDeposit: bigint;

    /**
     * The maximum number of sub-accounts allowed per identified account.
     **/
    maxSubAccounts: number;

    /**
     * Maximum number of registrars allowed in the system. Needed to bound the complexity
     * of, e.g., updating judgements.
     **/
    maxRegistrars: number;

    /**
     * The number of blocks within which a username grant must be accepted.
     **/
    pendingUsernameExpiration: number;

    /**
     * The maximum length of a suffix.
     **/
    maxSuffixLength: number;

    /**
     * The maximum length of a username, including its suffix and any system-added delimiters.
     **/
    maxUsernameLength: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Scheduler`'s constants
   **/
  scheduler: {
    /**
     * The maximum weight that may be scheduled per block for any dispatchables.
     **/
    maximumWeight: SpWeightsWeightV2Weight;

    /**
     * The maximum number of scheduled calls in the queue for a single block.
     *
     * NOTE:
     * + Dependent pallets' benchmarks might require a higher limit for the setting. Set a
     * higher limit under `runtime-benchmarks` feature.
     **/
    maxScheduledPerBlock: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Sudo`'s constants
   **/
  sudo: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Proxy`'s constants
   **/
  proxy: {
    /**
     * The base amount of currency needed to reserve for creating a proxy.
     *
     * This is held for an additional storage item whose value size is
     * `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes.
     **/
    proxyDepositBase: bigint;

    /**
     * The amount of currency needed per proxy added.
     *
     * This is held for adding 32 bytes plus an instance of `ProxyType` more into a
     * pre-existing storage value. Thus, when configuring `ProxyDepositFactor` one should take
     * into account `32 + proxy_type.encode().len()` bytes of data.
     **/
    proxyDepositFactor: bigint;

    /**
     * The maximum amount of proxies allowed for a single account.
     **/
    maxProxies: number;

    /**
     * The maximum amount of time-delayed announcements that are allowed to be pending.
     **/
    maxPending: number;

    /**
     * The base amount of currency needed to reserve for creating an announcement.
     *
     * This is held when a new storage item holding a `Balance` is created (typically 16
     * bytes).
     **/
    announcementDepositBase: bigint;

    /**
     * The amount of currency needed per announcement made.
     *
     * This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)
     * into a pre-existing storage value.
     **/
    announcementDepositFactor: bigint;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Multisig`'s constants
   **/
  multisig: {
    /**
     * The base amount of currency needed to reserve for creating a multisig execution or to
     * store a dispatch call for later.
     *
     * This is held for an additional storage item whose value size is
     * `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is
     * `32 + sizeof(AccountId)` bytes.
     **/
    depositBase: bigint;

    /**
     * The amount of currency needed per unit threshold when creating a multisig execution.
     *
     * This is held for adding 32 bytes more into a pre-existing storage value.
     **/
    depositFactor: bigint;

    /**
     * The maximum amount of signatories allowed in the multisig.
     **/
    maxSignatories: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `TransactionPayment`'s constants
   **/
  transactionPayment: {
    /**
     * A fee multiplier for `Operational` extrinsics to compute "virtual tip" to boost their
     * `priority`
     *
     * This value is multiplied by the `final_fee` to obtain a "virtual tip" that is later
     * added to a tip component in regular `priority` calculations.
     * It means that a `Normal` transaction can front-run a similarly-sized `Operational`
     * extrinsic (with no tip), by including a tip value greater than the virtual tip.
     *
     * ```rust,ignore
     * // For `Normal`
     * let priority = priority_calc(tip);
     *
     * // For `Operational`
     * let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;
     * let priority = priority_calc(tip + virtual_tip);
     * ```
     *
     * Note that since we use `final_fee` the multiplier applies also to the regular `tip`
     * sent with the transaction. So, not only does the transaction get a priority bump based
     * on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`
     * transactions.
     **/
    operationalFeeMultiplier: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Historical`'s constants
   **/
  historical: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Preimage`'s constants
   **/
  preimage: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Stakeholders`'s constants
   **/
  stakeholders: {
    /**
     * The MIDDS pallet instance pallet id
     **/
    palletId: FrameSupportPalletId;

    /**
     * The per-byte deposit cost when depositing MIDDS on-chain.
     **/
    byteDepositCost: bigint;

    /**
     * The maximum cost a user can lock in collateral for this MIDDS entity.
     * This help to ensure we don't go higher than the max of the balance type, in such case
     * the user would be able to don't pay any fees higher than this value.
     **/
    maxDepositCost: bigint;

    /**
     * How many time the depositor have to wait to remove the MIDDS.
     **/
    unregisterPeriod: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `MusicalWorks`'s constants
   **/
  musicalWorks: {
    /**
     * The MIDDS pallet instance pallet id
     **/
    palletId: FrameSupportPalletId;

    /**
     * The per-byte deposit cost when depositing MIDDS on-chain.
     **/
    byteDepositCost: bigint;

    /**
     * The maximum cost a user can lock in collateral for this MIDDS entity.
     * This help to ensure we don't go higher than the max of the balance type, in such case
     * the user would be able to don't pay any fees higher than this value.
     **/
    maxDepositCost: bigint;

    /**
     * How many time the depositor have to wait to remove the MIDDS.
     **/
    unregisterPeriod: number;

    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
  /**
   * Pallet `Mmr`'s constants
   **/
  mmr: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any;
  };
}

// Generated by dedot cli



interface ChainStorage<Rv extends RpcVersion>
  extends GenericChainStorage<Rv> {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => FrameSystemAccountInfo,
      AccountId32
    >;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<
      Rv,
      () => FrameSupportDispatchPerDispatchClass
    >;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<Rv, () => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<Rv, () => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<Rv, () => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<
      Rv,
      (arg: H256) => Array<[number, number]>,
      H256
    >;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemLastRuntimeUpgradeInfo | undefined
    >;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<Rv, () => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemCodeUpgradeAuthorization | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletBalancesAccountData,
      AccountId32
    >;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesBalanceLock>,
      AccountId32
    >;

    /**
     * Named reserves on some account balances.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesReserveData>,
      AccountId32
    >;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmount>,
      AccountId32
    >;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>> =} callback
     **/
    freezes: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Babe`'s storage queries
   **/
  babe: {
    /**
     * Current epoch index.
     *
     * @param {Callback<bigint> =} callback
     **/
    epochIndex: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Current epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<[SpConsensusBabeAppPublic, bigint]>
    >;

    /**
     * The slot at which the first epoch actually started. This is 0
     * until the first block of the chain.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    genesisSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * Current slot number.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * The epoch randomness for the *current* epoch.
     *
     * # Security
     *
     * This MUST NOT be used for gambling, as it can be influenced by a
     * malicious validator in the short term. It MAY be used in many
     * cryptographic protocols, however, so long as one remembers that this
     * (like everything else on-chain) it is public. For example, it can be
     * used where a number is needed that cannot have been chosen by an
     * adversary, for purposes such as public-coin zero-knowledge proofs.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    randomness: GenericStorageQuery<Rv, () => FixedBytes<32>>;

    /**
     * Pending epoch configuration change that will be applied when the next epoch is enacted.
     *
     * @param {Callback<SpConsensusBabeDigestsNextConfigDescriptor | undefined> =} callback
     **/
    pendingEpochConfigChange: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeDigestsNextConfigDescriptor | undefined
    >;

    /**
     * Next epoch randomness.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    nextRandomness: GenericStorageQuery<Rv, () => FixedBytes<32>>;

    /**
     * Next epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    nextAuthorities: GenericStorageQuery<
      Rv,
      () => Array<[SpConsensusBabeAppPublic, bigint]>
    >;

    /**
     * Randomness under construction.
     *
     * We make a trade-off between storage accesses and list length.
     * We store the under-construction randomness in segments of up to
     * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
     *
     * Once a segment reaches this length, we begin the next one.
     * We reset all segments and return to `0` at the beginning of every
     * epoch.
     *
     * @param {Callback<number> =} callback
     **/
    segmentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.
     *
     * @param {number} arg
     * @param {Callback<Array<FixedBytes<32>>> =} callback
     **/
    underConstruction: GenericStorageQuery<
      Rv,
      (arg: number) => Array<FixedBytes<32>>,
      number
    >;

    /**
     * Temporary value (cleared at block finalization) which is `Some`
     * if per-block initialization has already been called for current block.
     *
     * @param {Callback<SpConsensusBabeDigestsPreDigest | undefined | undefined> =} callback
     **/
    initialized: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeDigestsPreDigest | undefined | undefined
    >;

    /**
     * This field should always be populated during block processing unless
     * secondary plain slots are enabled (which don't contain a VRF output).
     *
     * It is set in `on_finalize`, before it will contain the value from the last block.
     *
     * @param {Callback<FixedBytes<32> | undefined> =} callback
     **/
    authorVrfRandomness: GenericStorageQuery<
      Rv,
      () => FixedBytes<32> | undefined
    >;

    /**
     * The block numbers when the last and current epoch have started, respectively `N-1` and
     * `N`.
     * NOTE: We track this is in order to annotate the block number when a given pool of
     * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
     * slots, which may be skipped, the block numbers may not line up with the slot numbers.
     *
     * @param {Callback<[number, number]> =} callback
     **/
    epochStart: GenericStorageQuery<Rv, () => [number, number]>;

    /**
     * How late the current block is compared to its parent.
     *
     * This entry is populated as part of block execution and is cleaned up
     * on block finalization. Querying this storage entry outside of block
     * execution context should always yield zero.
     *
     * @param {Callback<number> =} callback
     **/
    lateness: GenericStorageQuery<Rv, () => number>;

    /**
     * The configuration for the current epoch. Should never be `None` as it is initialized in
     * genesis.
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    epochConfig: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeBabeEpochConfiguration | undefined
    >;

    /**
     * The configuration for the next epoch, `None` if the config will not change
     * (you can fallback to `EpochConfig` instead in that case).
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    nextEpochConfig: GenericStorageQuery<
      Rv,
      () => SpConsensusBabeBabeEpochConfiguration | undefined
    >;

    /**
     * A list of the last 100 skipped epochs and the corresponding session index
     * when the epoch was skipped.
     *
     * This is only used for validating equivocation proofs. An equivocation proof
     * must contains a key-ownership proof for a given session, therefore we need a
     * way to tie together sessions and epoch indices, i.e. we need to validate that
     * a validator was the owner of a given key on a given session, and what the
     * active epoch index was during that session.
     *
     * @param {Callback<Array<[bigint, number]>> =} callback
     **/
    skippedEpochs: GenericStorageQuery<Rv, () => Array<[bigint, number]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ImOnline`'s storage queries
   **/
  imOnline: {
    /**
     * The block number after which it's ok to send heartbeats in the current
     * session.
     *
     * At the beginning of each session we set this to a value that should fall
     * roughly in the middle of the session duration. The idea is to first wait for
     * the validators to produce a block in the current session, so that the
     * heartbeat later on will not be necessary.
     *
     * This value will only be used as a fallback if we fail to get a proper session
     * progress estimate from `NextSessionRotation`, as those estimates should be
     * more accurate then the value we calculate for `HeartbeatAfter`.
     *
     * @param {Callback<number> =} callback
     **/
    heartbeatAfter: GenericStorageQuery<Rv, () => number>;

    /**
     * The current set of keys that may issue a heartbeat.
     *
     * @param {Callback<Array<PalletImOnlineSr25519AppSr25519Public>> =} callback
     **/
    keys: GenericStorageQuery<
      Rv,
      () => Array<PalletImOnlineSr25519AppSr25519Public>
    >;

    /**
     * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`.
     *
     * @param {[number, number]} arg
     * @param {Callback<boolean | undefined> =} callback
     **/
    receivedHeartbeats: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => boolean | undefined,
      [number, number]
    >;

    /**
     * For each session index, we keep a mapping of `ValidatorId<T>` to the
     * number of blocks authored by the given authority.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number> =} callback
     **/
    authoredBlocks: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => number,
      [number, AccountId32]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ValidatorSet`'s storage queries
   **/
  validatorSet: {
    /**
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    offlineValidators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, MelodieRuntimePalletsSessionSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<
      Rv,
      () => Array<[AccountId32, MelodieRuntimePalletsSessionSessionKeys]>
    >;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<MelodieRuntimePalletsSessionSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => MelodieRuntimePalletsSessionSessionKeys | undefined,
      AccountId32
    >;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      Rv,
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Grandpa`'s storage queries
   **/
  grandpa: {
    /**
     * State of the current authority set.
     *
     * @param {Callback<PalletGrandpaStoredState> =} callback
     **/
    state: GenericStorageQuery<Rv, () => PalletGrandpaStoredState>;

    /**
     * Pending change: (signaled at, scheduled change).
     *
     * @param {Callback<PalletGrandpaStoredPendingChange | undefined> =} callback
     **/
    pendingChange: GenericStorageQuery<
      Rv,
      () => PalletGrandpaStoredPendingChange | undefined
    >;

    /**
     * next block number where we can force a change.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextForced: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * `true` if we are currently stalled.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    stalled: GenericStorageQuery<Rv, () => [number, number] | undefined>;

    /**
     * The number of changes (both in terms of keys and underlying economic responsibilities)
     * in the "set" of Grandpa validators from genesis.
     *
     * @param {Callback<bigint> =} callback
     **/
    currentSetId: GenericStorageQuery<Rv, () => bigint>;

    /**
     * A mapping from grandpa set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `SetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<
      Rv,
      (arg: bigint) => number | undefined,
      bigint
    >;

    /**
     * The current list of authorities.
     *
     * @param {Callback<Array<[SpConsensusGrandpaAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<[SpConsensusGrandpaAppPublic, bigint]>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AuthorityDiscovery`'s storage queries
   **/
  authorityDiscovery: {
    /**
     * Keys of the current authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    keys: GenericStorageQuery<Rv, () => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Keys of the next authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    nextKeys: GenericStorageQuery<
      Rv,
      () => Array<SpAuthorityDiscoveryAppPublic>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Identity`'s storage queries
   **/
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account. First item is the
     * registration, second is the account's primary username.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[PalletIdentityRegistration, Bytes | undefined] | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => [PalletIdentityRegistration, Bytes | undefined] | undefined,
      AccountId32
    >;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[AccountId32, Data] | undefined> =} callback
     **/
    superOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [AccountId32, Data] | undefined,
      AccountId32
    >;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, Array<AccountId32>]> =} callback
     **/
    subsOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [bigint, Array<AccountId32>],
      AccountId32
    >;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     *
     * @param {Callback<Array<PalletIdentityRegistrarInfo | undefined>> =} callback
     **/
    registrars: GenericStorageQuery<
      Rv,
      () => Array<PalletIdentityRegistrarInfo | undefined>
    >;

    /**
     * A map of the accounts who are authorized to grant usernames.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletIdentityAuthorityProperties | undefined> =} callback
     **/
    usernameAuthorities: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletIdentityAuthorityProperties | undefined,
      AccountId32
    >;

    /**
     * Reverse lookup from `username` to the `AccountId` that has registered it. The value should
     * be a key in the `IdentityOf` map, but it may not if the user has cleared their identity.
     *
     * Multiple usernames may map to the same `AccountId`, but `IdentityOf` will only map to one
     * primary username.
     *
     * @param {BytesLike} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    accountOfUsername: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => AccountId32 | undefined,
      Bytes
    >;

    /**
     * Usernames that an authority has granted, but that the account controller has not confirmed
     * that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
     * because they are a pure proxy, multisig, etc. In order to confirm it, they should call
     * [`Call::accept_username`].
     *
     * First tuple item is the account and second is the acceptance deadline.
     *
     * @param {BytesLike} arg
     * @param {Callback<[AccountId32, number] | undefined> =} callback
     **/
    pendingUsernames: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => [AccountId32, number] | undefined,
      Bytes
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<
      Rv,
      (arg: number) => Array<PalletSchedulerScheduled | undefined>,
      number
    >;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletSchedulerRetryConfig | undefined,
      [number, number]
    >;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<
      Rv,
      (arg: FixedBytes<32>) => [number, number] | undefined,
      FixedBytes<32>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Sudo`'s storage queries
   **/
  sudo: {
    /**
     * The `AccountId` of the sudo key.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    key: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint],
      AccountId32
    >;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint],
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      Rv,
      (
        arg: [AccountId32Like, FixedBytes<32>],
      ) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<
      Rv,
      () => PalletTransactionPaymentReleases
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Historical`'s storage queries
   **/
  historical: {
    /**
     * Mapping from historical session indices to session-data root hash and validator count.
     *
     * @param {number} arg
     * @param {Callback<[H256, number] | undefined> =} callback
     **/
    historicalSessions: GenericStorageQuery<
      Rv,
      (arg: number) => [H256, number] | undefined,
      number
    >;

    /**
     * The range of historical sessions we store. [first, last)
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    storedRange: GenericStorageQuery<Rv, () => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageOldRequestStatus | undefined,
      H256
    >;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageRequestStatus | undefined,
      H256
    >;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<
      Rv,
      (arg: [H256, number]) => Bytes | undefined,
      [H256, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Stakeholders`'s storage queries
   **/
  stakeholders: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<PalletMiddsMiddsWrapper | undefined> =} callback
     **/
    pendingMidds: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletMiddsMiddsWrapper | undefined,
      H256
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MusicalWorks`'s storage queries
   **/
  musicalWorks: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<PalletMiddsMiddsWrapperSong | undefined> =} callback
     **/
    pendingMidds: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletMiddsMiddsWrapperSong | undefined,
      H256
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Mmr`'s storage queries
   **/
  mmr: {
    /**
     * Latest MMR Root hash.
     *
     * @param {Callback<H256> =} callback
     **/
    rootHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Current size of the MMR (number of leaves).
     *
     * @param {Callback<bigint> =} callback
     **/
    numberOfLeaves: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Hashes of the nodes in the MMR.
     *
     * Note this collection only contains MMR peaks, the inner nodes (and leaves)
     * are pruned and only stored in the Offchain DB.
     *
     * @param {bigint} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    nodes: GenericStorageQuery<Rv, (arg: bigint) => H256 | undefined, bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
}

// Generated by dedot cli



type ChainJsonRpcApis<Rv extends RpcVersion> = Pick<
  JsonRpcApis,
  | 'author_hasKey'
  | 'author_hasSessionKeys'
  | 'author_insertKey'
  | 'author_pendingExtrinsics'
  | 'author_removeExtrinsic'
  | 'author_rotateKeys'
  | 'author_submitAndWatchExtrinsic'
  | 'author_submitExtrinsic'
  | 'babe_epochAuthorship'
  | 'chainHead_v1_body'
  | 'chainHead_v1_call'
  | 'chainHead_v1_continue'
  | 'chainHead_v1_follow'
  | 'chainHead_v1_header'
  | 'chainHead_v1_stopOperation'
  | 'chainHead_v1_storage'
  | 'chainHead_v1_unpin'
  | 'chainSpec_v1_chainName'
  | 'chainSpec_v1_genesisHash'
  | 'chainSpec_v1_properties'
  | 'chain_getBlock'
  | 'chain_getBlockHash'
  | 'chain_getFinalizedHead'
  | 'chain_getHeader'
  | 'chain_subscribeAllHeads'
  | 'chain_subscribeFinalizedHeads'
  | 'chain_subscribeNewHeads'
  | 'childstate_getKeys'
  | 'childstate_getKeysPaged'
  | 'childstate_getStorage'
  | 'childstate_getStorageEntries'
  | 'childstate_getStorageHash'
  | 'childstate_getStorageSize'
  | 'grandpa_proveFinality'
  | 'grandpa_roundState'
  | 'grandpa_subscribeJustifications'
  | 'offchain_localStorageGet'
  | 'offchain_localStorageSet'
  | 'payment_queryFeeDetails'
  | 'payment_queryInfo'
  | 'rpc_methods'
  | 'state_call'
  | 'state_getChildReadProof'
  | 'state_getKeys'
  | 'state_getKeysPaged'
  | 'state_getMetadata'
  | 'state_getPairs'
  | 'state_getReadProof'
  | 'state_getRuntimeVersion'
  | 'state_getStorage'
  | 'state_getStorageHash'
  | 'state_getStorageSize'
  | 'state_queryStorage'
  | 'state_queryStorageAt'
  | 'state_subscribeRuntimeVersion'
  | 'state_subscribeStorage'
  | 'state_traceBlock'
  | 'sync_state_genSyncSpec'
  | 'system_accountNextIndex'
  | 'system_addLogFilter'
  | 'system_addReservedPeer'
  | 'system_chain'
  | 'system_chainType'
  | 'system_dryRun'
  | 'system_health'
  | 'system_localListenAddresses'
  | 'system_localPeerId'
  | 'system_name'
  | 'system_nodeRoles'
  | 'system_peers'
  | 'system_properties'
  | 'system_removeReservedPeer'
  | 'system_reservedPeers'
  | 'system_resetLogFilter'
  | 'system_syncState'
  | 'system_unstable_networkState'
  | 'system_version'
  | 'transactionWatch_v1_submitAndWatch'
  | 'transaction_v1_broadcast'
  | 'transaction_v1_stop'
> &
  GenericJsonRpcApis<Rv>;

// Generated by dedot cli



interface ChainErrors<Rv extends RpcVersion>
  extends GenericChainErrors<Rv> {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError<Rv>;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError<Rv>;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError<Rv>;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError<Rv>;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError<Rv>;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError<Rv>;

    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     **/
    MultiBlockMigrationsOngoing: GenericPalletError<Rv>;

    /**
     * The specified [`Task`] is not valid.
     **/
    InvalidTask: GenericPalletError<Rv>;

    /**
     * The specified [`Task`] failed during execution.
     **/
    FailedTask: GenericPalletError<Rv>;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError<Rv>;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError<Rv>;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError<Rv>;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError<Rv>;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError<Rv>;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError<Rv>;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError<Rv>;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError<Rv>;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError<Rv>;

    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     **/
    TooManyHolds: GenericPalletError<Rv>;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError<Rv>;

    /**
     * The issuance cannot be modified since it is already deactivated.
     **/
    IssuanceDeactivated: GenericPalletError<Rv>;

    /**
     * The delta cannot be zero.
     **/
    DeltaZero: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Babe`'s errors
   **/
  babe: {
    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError<Rv>;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError<Rv>;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError<Rv>;

    /**
     * Submitted configuration is invalid.
     **/
    InvalidConfiguration: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ImOnline`'s errors
   **/
  imOnline: {
    /**
     * Non existent public key.
     **/
    InvalidKey: GenericPalletError<Rv>;

    /**
     * Duplicated heartbeat.
     **/
    DuplicatedHeartbeat: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ValidatorSet`'s errors
   **/
  validatorSet: {
    /**
     * Target (post-removal) validator count is below the minimum.
     **/
    TooLowValidatorCount: GenericPalletError<Rv>;

    /**
     * Validator is already in the validator set.
     **/
    Duplicate: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError<Rv>;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError<Rv>;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError<Rv>;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError<Rv>;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Grandpa`'s errors
   **/
  grandpa: {
    /**
     * Attempt to signal GRANDPA pause when the authority set isn't live
     * (either paused or already pending pause).
     **/
    PauseFailed: GenericPalletError<Rv>;

    /**
     * Attempt to signal GRANDPA resume when the authority set isn't paused
     * (either live or already pending resume).
     **/
    ResumeFailed: GenericPalletError<Rv>;

    /**
     * Attempt to signal GRANDPA change with one already pending.
     **/
    ChangePending: GenericPalletError<Rv>;

    /**
     * Cannot signal forced change so soon after last.
     **/
    TooSoon: GenericPalletError<Rv>;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError<Rv>;

    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError<Rv>;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError<Rv>;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError<Rv>;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError<Rv>;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError<Rv>;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError<Rv>;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError<Rv>;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError<Rv>;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError<Rv>;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError<Rv>;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError<Rv>;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError<Rv>;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError<Rv>;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError<Rv>;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError<Rv>;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError<Rv>;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError<Rv>;

    /**
     * The provided suffix is too long.
     **/
    InvalidSuffix: GenericPalletError<Rv>;

    /**
     * The sender does not have permission to issue a username.
     **/
    NotUsernameAuthority: GenericPalletError<Rv>;

    /**
     * The authority cannot allocate any more usernames.
     **/
    NoAllocation: GenericPalletError<Rv>;

    /**
     * The signature on a username was not valid.
     **/
    InvalidSignature: GenericPalletError<Rv>;

    /**
     * Setting this username requires a signature, but none was provided.
     **/
    RequiresSignature: GenericPalletError<Rv>;

    /**
     * The username does not meet the requirements.
     **/
    InvalidUsername: GenericPalletError<Rv>;

    /**
     * The username is already taken.
     **/
    UsernameTaken: GenericPalletError<Rv>;

    /**
     * The requested username does not exist.
     **/
    NoUsername: GenericPalletError<Rv>;

    /**
     * The username cannot be forcefully removed because it can still be accepted.
     **/
    NotExpired: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Scheduler`'s errors
   **/
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    FailedToSchedule: GenericPalletError<Rv>;

    /**
     * Cannot find the scheduled call.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Given target block number is in the past.
     **/
    TargetBlockNumberInPast: GenericPalletError<Rv>;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    RescheduleNoChange: GenericPalletError<Rv>;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    Named: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Sudo`'s errors
   **/
  sudo: {
    /**
     * Sender must be the Sudo account.
     **/
    RequireSudo: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError<Rv>;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError<Rv>;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError<Rv>;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError<Rv>;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError<Rv>;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError<Rv>;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError<Rv>;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError<Rv>;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError<Rv>;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError<Rv>;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError<Rv>;

    /**
     * Multisig operation not found when attempting to cancel.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Only the account that originally created the multisig is able to cancel it.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError<Rv>;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError<Rv>;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError<Rv>;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError<Rv>;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Preimage`'s errors
   **/
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    TooBig: GenericPalletError<Rv>;

    /**
     * Preimage has already been noted on-chain.
     **/
    AlreadyNoted: GenericPalletError<Rv>;

    /**
     * The user is not authorized to perform this action.
     **/
    NotAuthorized: GenericPalletError<Rv>;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    NotNoted: GenericPalletError<Rv>;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    Requested: GenericPalletError<Rv>;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    NotRequested: GenericPalletError<Rv>;

    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     **/
    TooFew: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Stakeholders`'s errors
   **/
  stakeholders: {
    /**
     * A MIDDS with the same hash ID (so the same data) is already registered.
     **/
    MiddsDataAlreadyExist: GenericPalletError<Rv>;

    /**
     * The specified MIDDS ID is not related to any pending MIDDS.
     **/
    PendingMiddsNotFound: GenericPalletError<Rv>;

    /**
     * The lock-unregister period is still going.
     **/
    UnregisterLocked: GenericPalletError<Rv>;

    /**
     * The caller is not the provider of the MIDDS.
     **/
    NotProvider: GenericPalletError<Rv>;

    /**
     * Funds can't be released at this moment.
     **/
    CantReleaseFunds: GenericPalletError<Rv>;

    /**
     * Funds can't be held at this moment.
     **/
    CantHoldFunds: GenericPalletError<Rv>;

    /**
     * The provider tried to register/update a MIDDS that exceed data size cost maximum authorized.
     **/
    OverflowedAuthorizedDataCost: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `MusicalWorks`'s errors
   **/
  musicalWorks: {
    /**
     * A MIDDS with the same hash ID (so the same data) is already registered.
     **/
    MiddsDataAlreadyExist: GenericPalletError<Rv>;

    /**
     * The specified MIDDS ID is not related to any pending MIDDS.
     **/
    PendingMiddsNotFound: GenericPalletError<Rv>;

    /**
     * The lock-unregister period is still going.
     **/
    UnregisterLocked: GenericPalletError<Rv>;

    /**
     * The caller is not the provider of the MIDDS.
     **/
    NotProvider: GenericPalletError<Rv>;

    /**
     * Funds can't be released at this moment.
     **/
    CantReleaseFunds: GenericPalletError<Rv>;

    /**
     * Funds can't be held at this moment.
     **/
    CantHoldFunds: GenericPalletError<Rv>;

    /**
     * The provider tried to register/update a MIDDS that exceed data size cost maximum authorized.
     **/
    OverflowedAuthorizedDataCost: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
}

// Generated by dedot cli



interface ChainEvents<Rv extends RpcVersion>
  extends GenericChainEvents<Rv> {
  /**
   * Pallet `System`'s events
   **/
  system: {
    /**
     * An extrinsic completed successfully.
     **/
    ExtrinsicSuccess: GenericPalletEvent<
      Rv,
      'System',
      'ExtrinsicSuccess',
      { dispatchInfo: DispatchInfo }
    >;

    /**
     * An extrinsic failed.
     **/
    ExtrinsicFailed: GenericPalletEvent<
      Rv,
      'System',
      'ExtrinsicFailed',
      { dispatchError: DispatchError; dispatchInfo: DispatchInfo }
    >;

    /**
     * `:code` was updated.
     **/
    CodeUpdated: GenericPalletEvent<Rv, 'System', 'CodeUpdated', null>;

    /**
     * A new account was created.
     **/
    NewAccount: GenericPalletEvent<
      Rv,
      'System',
      'NewAccount',
      { account: AccountId32 }
    >;

    /**
     * An account was reaped.
     **/
    KilledAccount: GenericPalletEvent<
      Rv,
      'System',
      'KilledAccount',
      { account: AccountId32 }
    >;

    /**
     * On on-chain remark happened.
     **/
    Remarked: GenericPalletEvent<
      Rv,
      'System',
      'Remarked',
      { sender: AccountId32; hash: H256 }
    >;

    /**
     * A [`Task`] has started executing
     **/
    TaskStarted: GenericPalletEvent<
      Rv,
      'System',
      'TaskStarted',
      { task: MelodieRuntimeRuntimeTask }
    >;

    /**
     * A [`Task`] has finished executing.
     **/
    TaskCompleted: GenericPalletEvent<
      Rv,
      'System',
      'TaskCompleted',
      { task: MelodieRuntimeRuntimeTask }
    >;

    /**
     * A [`Task`] failed during execution.
     **/
    TaskFailed: GenericPalletEvent<
      Rv,
      'System',
      'TaskFailed',
      { task: MelodieRuntimeRuntimeTask; err: DispatchError }
    >;

    /**
     * An upgrade was authorized.
     **/
    UpgradeAuthorized: GenericPalletEvent<
      Rv,
      'System',
      'UpgradeAuthorized',
      { codeHash: H256; checkVersion: boolean }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Balances`'s events
   **/
  balances: {
    /**
     * An account was created with some free balance.
     **/
    Endowed: GenericPalletEvent<
      Rv,
      'Balances',
      'Endowed',
      { account: AccountId32; freeBalance: bigint }
    >;

    /**
     * An account was removed whose balance was non-zero but below ExistentialDeposit,
     * resulting in an outright loss.
     **/
    DustLost: GenericPalletEvent<
      Rv,
      'Balances',
      'DustLost',
      { account: AccountId32; amount: bigint }
    >;

    /**
     * Transfer succeeded.
     **/
    Transfer: GenericPalletEvent<
      Rv,
      'Balances',
      'Transfer',
      { from: AccountId32; to: AccountId32; amount: bigint }
    >;

    /**
     * A balance was set by root.
     **/
    BalanceSet: GenericPalletEvent<
      Rv,
      'Balances',
      'BalanceSet',
      { who: AccountId32; free: bigint }
    >;

    /**
     * Some balance was reserved (moved from free to reserved).
     **/
    Reserved: GenericPalletEvent<
      Rv,
      'Balances',
      'Reserved',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some balance was unreserved (moved from reserved to free).
     **/
    Unreserved: GenericPalletEvent<
      Rv,
      'Balances',
      'Unreserved',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some balance was moved from the reserve of the first account to the second account.
     * Final argument indicates the destination balance type.
     **/
    ReserveRepatriated: GenericPalletEvent<
      Rv,
      'Balances',
      'ReserveRepatriated',
      {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      }
    >;

    /**
     * Some amount was deposited (e.g. for transaction fees).
     **/
    Deposit: GenericPalletEvent<
      Rv,
      'Balances',
      'Deposit',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some amount was withdrawn from the account (e.g. for transaction fees).
     **/
    Withdraw: GenericPalletEvent<
      Rv,
      'Balances',
      'Withdraw',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some amount was removed from the account (e.g. for misbehavior).
     **/
    Slashed: GenericPalletEvent<
      Rv,
      'Balances',
      'Slashed',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some amount was minted into an account.
     **/
    Minted: GenericPalletEvent<
      Rv,
      'Balances',
      'Minted',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some amount was burned from an account.
     **/
    Burned: GenericPalletEvent<
      Rv,
      'Balances',
      'Burned',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some amount was suspended from an account (it can be restored later).
     **/
    Suspended: GenericPalletEvent<
      Rv,
      'Balances',
      'Suspended',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some amount was restored into an account.
     **/
    Restored: GenericPalletEvent<
      Rv,
      'Balances',
      'Restored',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * An account was upgraded.
     **/
    Upgraded: GenericPalletEvent<
      Rv,
      'Balances',
      'Upgraded',
      { who: AccountId32 }
    >;

    /**
     * Total issuance was increased by `amount`, creating a credit to be balanced.
     **/
    Issued: GenericPalletEvent<Rv, 'Balances', 'Issued', { amount: bigint }>;

    /**
     * Total issuance was decreased by `amount`, creating a debt to be balanced.
     **/
    Rescinded: GenericPalletEvent<
      Rv,
      'Balances',
      'Rescinded',
      { amount: bigint }
    >;

    /**
     * Some balance was locked.
     **/
    Locked: GenericPalletEvent<
      Rv,
      'Balances',
      'Locked',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some balance was unlocked.
     **/
    Unlocked: GenericPalletEvent<
      Rv,
      'Balances',
      'Unlocked',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some balance was frozen.
     **/
    Frozen: GenericPalletEvent<
      Rv,
      'Balances',
      'Frozen',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * Some balance was thawed.
     **/
    Thawed: GenericPalletEvent<
      Rv,
      'Balances',
      'Thawed',
      { who: AccountId32; amount: bigint }
    >;

    /**
     * The `TotalIssuance` was forcefully changed.
     **/
    TotalIssuanceForced: GenericPalletEvent<
      Rv,
      'Balances',
      'TotalIssuanceForced',
      { old: bigint; new: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `ImOnline`'s events
   **/
  imOnline: {
    /**
     * A new heartbeat was received from `AuthorityId`.
     **/
    HeartbeatReceived: GenericPalletEvent<
      Rv,
      'ImOnline',
      'HeartbeatReceived',
      { authorityId: PalletImOnlineSr25519AppSr25519Public }
    >;

    /**
     * At the end of the session, no offence was committed.
     **/
    AllGood: GenericPalletEvent<Rv, 'ImOnline', 'AllGood', null>;

    /**
     * At the end of the session, at least one validator was found to be offline.
     **/
    SomeOffline: GenericPalletEvent<
      Rv,
      'ImOnline',
      'SomeOffline',
      { offline: Array<[AccountId32, AccountId32]> }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `ValidatorSet`'s events
   **/
  validatorSet: {
    /**
     * New validator addition initiated. Effective in ~2 sessions.
     **/
    ValidatorAdditionInitiated: GenericPalletEvent<
      Rv,
      'ValidatorSet',
      'ValidatorAdditionInitiated',
      AccountId32
    >;

    /**
     * Validator removal initiated. Effective in ~2 sessions.
     **/
    ValidatorRemovalInitiated: GenericPalletEvent<
      Rv,
      'ValidatorSet',
      'ValidatorRemovalInitiated',
      AccountId32
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Session`'s events
   **/
  session: {
    /**
     * New session has happened. Note that the argument is the session index, not the
     * block number as the type might suggest.
     **/
    NewSession: GenericPalletEvent<
      Rv,
      'Session',
      'NewSession',
      { sessionIndex: number }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Grandpa`'s events
   **/
  grandpa: {
    /**
     * New authority set has been applied.
     **/
    NewAuthorities: GenericPalletEvent<
      Rv,
      'Grandpa',
      'NewAuthorities',
      { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> }
    >;

    /**
     * Current authority set has been paused.
     **/
    Paused: GenericPalletEvent<Rv, 'Grandpa', 'Paused', null>;

    /**
     * Current authority set has been resumed.
     **/
    Resumed: GenericPalletEvent<Rv, 'Grandpa', 'Resumed', null>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Utility`'s events
   **/
  utility: {
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     **/
    BatchInterrupted: GenericPalletEvent<
      Rv,
      'Utility',
      'BatchInterrupted',
      { index: number; error: DispatchError }
    >;

    /**
     * Batch of dispatches completed fully with no error.
     **/
    BatchCompleted: GenericPalletEvent<Rv, 'Utility', 'BatchCompleted', null>;

    /**
     * Batch of dispatches completed but has errors.
     **/
    BatchCompletedWithErrors: GenericPalletEvent<
      Rv,
      'Utility',
      'BatchCompletedWithErrors',
      null
    >;

    /**
     * A single item within a Batch of dispatches has completed with no error.
     **/
    ItemCompleted: GenericPalletEvent<Rv, 'Utility', 'ItemCompleted', null>;

    /**
     * A single item within a Batch of dispatches has completed with error.
     **/
    ItemFailed: GenericPalletEvent<
      Rv,
      'Utility',
      'ItemFailed',
      { error: DispatchError }
    >;

    /**
     * A call was dispatched.
     **/
    DispatchedAs: GenericPalletEvent<
      Rv,
      'Utility',
      'DispatchedAs',
      { result: Result<[], DispatchError> }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Identity`'s events
   **/
  identity: {
    /**
     * A name was set or reset (which will remove all judgements).
     **/
    IdentitySet: GenericPalletEvent<
      Rv,
      'Identity',
      'IdentitySet',
      { who: AccountId32 }
    >;

    /**
     * A name was cleared, and the given balance returned.
     **/
    IdentityCleared: GenericPalletEvent<
      Rv,
      'Identity',
      'IdentityCleared',
      { who: AccountId32; deposit: bigint }
    >;

    /**
     * A name was removed and the given balance slashed.
     **/
    IdentityKilled: GenericPalletEvent<
      Rv,
      'Identity',
      'IdentityKilled',
      { who: AccountId32; deposit: bigint }
    >;

    /**
     * A judgement was asked from a registrar.
     **/
    JudgementRequested: GenericPalletEvent<
      Rv,
      'Identity',
      'JudgementRequested',
      { who: AccountId32; registrarIndex: number }
    >;

    /**
     * A judgement request was retracted.
     **/
    JudgementUnrequested: GenericPalletEvent<
      Rv,
      'Identity',
      'JudgementUnrequested',
      { who: AccountId32; registrarIndex: number }
    >;

    /**
     * A judgement was given by a registrar.
     **/
    JudgementGiven: GenericPalletEvent<
      Rv,
      'Identity',
      'JudgementGiven',
      { target: AccountId32; registrarIndex: number }
    >;

    /**
     * A registrar was added.
     **/
    RegistrarAdded: GenericPalletEvent<
      Rv,
      'Identity',
      'RegistrarAdded',
      { registrarIndex: number }
    >;

    /**
     * A sub-identity was added to an identity and the deposit paid.
     **/
    SubIdentityAdded: GenericPalletEvent<
      Rv,
      'Identity',
      'SubIdentityAdded',
      { sub: AccountId32; main: AccountId32; deposit: bigint }
    >;

    /**
     * A sub-identity was removed from an identity and the deposit freed.
     **/
    SubIdentityRemoved: GenericPalletEvent<
      Rv,
      'Identity',
      'SubIdentityRemoved',
      { sub: AccountId32; main: AccountId32; deposit: bigint }
    >;

    /**
     * A sub-identity was cleared, and the given deposit repatriated from the
     * main identity account to the sub-identity account.
     **/
    SubIdentityRevoked: GenericPalletEvent<
      Rv,
      'Identity',
      'SubIdentityRevoked',
      { sub: AccountId32; main: AccountId32; deposit: bigint }
    >;

    /**
     * A username authority was added.
     **/
    AuthorityAdded: GenericPalletEvent<
      Rv,
      'Identity',
      'AuthorityAdded',
      { authority: AccountId32 }
    >;

    /**
     * A username authority was removed.
     **/
    AuthorityRemoved: GenericPalletEvent<
      Rv,
      'Identity',
      'AuthorityRemoved',
      { authority: AccountId32 }
    >;

    /**
     * A username was set for `who`.
     **/
    UsernameSet: GenericPalletEvent<
      Rv,
      'Identity',
      'UsernameSet',
      { who: AccountId32; username: Bytes }
    >;

    /**
     * A username was queued, but `who` must accept it prior to `expiration`.
     **/
    UsernameQueued: GenericPalletEvent<
      Rv,
      'Identity',
      'UsernameQueued',
      { who: AccountId32; username: Bytes; expiration: number }
    >;

    /**
     * A queued username passed its expiration without being claimed and was removed.
     **/
    PreapprovalExpired: GenericPalletEvent<
      Rv,
      'Identity',
      'PreapprovalExpired',
      { whose: AccountId32 }
    >;

    /**
     * A username was set as a primary and can be looked up from `who`.
     **/
    PrimaryUsernameSet: GenericPalletEvent<
      Rv,
      'Identity',
      'PrimaryUsernameSet',
      { who: AccountId32; username: Bytes }
    >;

    /**
     * A dangling username (as in, a username corresponding to an account that has removed its
     * identity) has been removed.
     **/
    DanglingUsernameRemoved: GenericPalletEvent<
      Rv,
      'Identity',
      'DanglingUsernameRemoved',
      { who: AccountId32; username: Bytes }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Scheduler`'s events
   **/
  scheduler: {
    /**
     * Scheduled some task.
     **/
    Scheduled: GenericPalletEvent<
      Rv,
      'Scheduler',
      'Scheduled',
      { when: number; index: number }
    >;

    /**
     * Canceled some task.
     **/
    Canceled: GenericPalletEvent<
      Rv,
      'Scheduler',
      'Canceled',
      { when: number; index: number }
    >;

    /**
     * Dispatched some task.
     **/
    Dispatched: GenericPalletEvent<
      Rv,
      'Scheduler',
      'Dispatched',
      {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        result: Result<[], DispatchError>;
      }
    >;

    /**
     * Set a retry configuration for some task.
     **/
    RetrySet: GenericPalletEvent<
      Rv,
      'Scheduler',
      'RetrySet',
      {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        period: number;
        retries: number;
      }
    >;

    /**
     * Cancel a retry configuration for some task.
     **/
    RetryCancelled: GenericPalletEvent<
      Rv,
      'Scheduler',
      'RetryCancelled',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The call for the provided hash was not found so the task has been aborted.
     **/
    CallUnavailable: GenericPalletEvent<
      Rv,
      'Scheduler',
      'CallUnavailable',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The given task was unable to be renewed since the agenda is full at that block.
     **/
    PeriodicFailed: GenericPalletEvent<
      Rv,
      'Scheduler',
      'PeriodicFailed',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The given task was unable to be retried since the agenda is full at that block or there
     * was not enough weight to reschedule it.
     **/
    RetryFailed: GenericPalletEvent<
      Rv,
      'Scheduler',
      'RetryFailed',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The given task can never be executed since it is overweight.
     **/
    PermanentlyOverweight: GenericPalletEvent<
      Rv,
      'Scheduler',
      'PermanentlyOverweight',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Sudo`'s events
   **/
  sudo: {
    /**
     * A sudo call just took place.
     **/
    Sudid: GenericPalletEvent<
      Rv,
      'Sudo',
      'Sudid',
      {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      }
    >;

    /**
     * The sudo key has been updated.
     **/
    KeyChanged: GenericPalletEvent<
      Rv,
      'Sudo',
      'KeyChanged',
      {
        /**
         * The old sudo key (if one was previously set).
         **/
        old?: AccountId32 | undefined;

        /**
         * The new sudo key (if one was set).
         **/
        new: AccountId32;
      }
    >;

    /**
     * The key was permanently removed.
     **/
    KeyRemoved: GenericPalletEvent<Rv, 'Sudo', 'KeyRemoved', null>;

    /**
     * A [sudo_as](Pallet::sudo_as) call just took place.
     **/
    SudoAsDone: GenericPalletEvent<
      Rv,
      'Sudo',
      'SudoAsDone',
      {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Proxy`'s events
   **/
  proxy: {
    /**
     * A proxy was executed correctly, with the given.
     **/
    ProxyExecuted: GenericPalletEvent<
      Rv,
      'Proxy',
      'ProxyExecuted',
      { result: Result<[], DispatchError> }
    >;

    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     **/
    PureCreated: GenericPalletEvent<
      Rv,
      'Proxy',
      'PureCreated',
      {
        pure: AccountId32;
        who: AccountId32;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        disambiguationIndex: number;
      }
    >;

    /**
     * An announcement was placed to make a call in the future.
     **/
    Announced: GenericPalletEvent<
      Rv,
      'Proxy',
      'Announced',
      { real: AccountId32; proxy: AccountId32; callHash: H256 }
    >;

    /**
     * A proxy was added.
     **/
    ProxyAdded: GenericPalletEvent<
      Rv,
      'Proxy',
      'ProxyAdded',
      {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        delay: number;
      }
    >;

    /**
     * A proxy was removed.
     **/
    ProxyRemoved: GenericPalletEvent<
      Rv,
      'Proxy',
      'ProxyRemoved',
      {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: MelodieRuntimePalletsProxyProxyType;
        delay: number;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Multisig`'s events
   **/
  multisig: {
    /**
     * A new multisig operation has begun.
     **/
    NewMultisig: GenericPalletEvent<
      Rv,
      'Multisig',
      'NewMultisig',
      {
        approving: AccountId32;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      }
    >;

    /**
     * A multisig operation has been approved by someone.
     **/
    MultisigApproval: GenericPalletEvent<
      Rv,
      'Multisig',
      'MultisigApproval',
      {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      }
    >;

    /**
     * A multisig operation has been executed.
     **/
    MultisigExecuted: GenericPalletEvent<
      Rv,
      'Multisig',
      'MultisigExecuted',
      {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      }
    >;

    /**
     * A multisig operation has been cancelled.
     **/
    MultisigCancelled: GenericPalletEvent<
      Rv,
      'Multisig',
      'MultisigCancelled',
      {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `TransactionPayment`'s events
   **/
  transactionPayment: {
    /**
     * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
     * has been paid by `who`.
     **/
    TransactionFeePaid: GenericPalletEvent<
      Rv,
      'TransactionPayment',
      'TransactionFeePaid',
      { who: AccountId32; actualFee: bigint; tip: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Preimage`'s events
   **/
  preimage: {
    /**
     * A preimage has been noted.
     **/
    Noted: GenericPalletEvent<Rv, 'Preimage', 'Noted', { hash: H256 }>;

    /**
     * A preimage has been requested.
     **/
    Requested: GenericPalletEvent<Rv, 'Preimage', 'Requested', { hash: H256 }>;

    /**
     * A preimage has ben cleared.
     **/
    Cleared: GenericPalletEvent<Rv, 'Preimage', 'Cleared', { hash: H256 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `Stakeholders`'s events
   **/
  stakeholders: {
    MiddsRegistered: GenericPalletEvent<
      Rv,
      'Stakeholders',
      'MIDDSRegistered',
      { provider: AccountId32; hashId: H256; dataColateral: bigint }
    >;
    MiddsUpdated: GenericPalletEvent<
      Rv,
      'Stakeholders',
      'MIDDSUpdated',
      { hashId: H256 }
    >;
    MiddsUnregistered: GenericPalletEvent<
      Rv,
      'Stakeholders',
      'MIDDSUnregistered',
      { hashId: H256 }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
  /**
   * Pallet `MusicalWorks`'s events
   **/
  musicalWorks: {
    MiddsRegistered: GenericPalletEvent<
      Rv,
      'MusicalWorks',
      'MIDDSRegistered',
      { provider: AccountId32; hashId: H256; dataColateral: bigint }
    >;
    MiddsUpdated: GenericPalletEvent<
      Rv,
      'MusicalWorks',
      'MIDDSUpdated',
      { hashId: H256 }
    >;
    MiddsUnregistered: GenericPalletEvent<
      Rv,
      'MusicalWorks',
      'MIDDSUnregistered',
      { hashId: H256 }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent<Rv>;
  };
}

// Generated by dedot cli



interface RuntimeApis<Rv extends RpcVersion>
  extends GenericRuntimeApis<Rv> {
  /**
   * @runtimeapi: Metadata - 0x37e397fc7c91f5e4
   * @version: 2
   **/
  metadata: {
    /**
     * Returns the metadata at a given version.
     *
     * @callname: Metadata_metadata_at_version
     * @param {number} version
     **/
    metadataAtVersion: GenericRuntimeApiMethod<
      Rv,
      (version: number) => Promise<Option<OpaqueMetadata>>
    >;

    /**
     * Returns the supported metadata versions.
     *
     * @callname: Metadata_metadata_versions
     **/
    metadataVersions: GenericRuntimeApiMethod<Rv, () => Promise<Array<number>>>;

    /**
     * Returns the metadata of a runtime.
     *
     * @callname: Metadata_metadata
     **/
    metadata: GenericRuntimeApiMethod<Rv, () => Promise<OpaqueMetadata>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BlockBuilder - 0x40fe3ad401f8959a
   * @version: 6
   **/
  blockBuilder: {
    /**
     *
     * @callname: BlockBuilder_apply_extrinsic
     * @param {OpaqueExtrinsicLike} extrinsic
     **/
    applyExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (extrinsic: OpaqueExtrinsicLike) => Promise<ApplyExtrinsicResult>
    >;

    /**
     *
     * @callname: BlockBuilder_check_inherents
     * @param {Block} block
     * @param {InherentData} data
     **/
    checkInherents: GenericRuntimeApiMethod<
      Rv,
      (block: Block, data: InherentData) => Promise<CheckInherentsResult>
    >;

    /**
     *
     * @callname: BlockBuilder_inherent_extrinsics
     * @param {InherentData} inherent
     **/
    inherentExtrinsics: GenericRuntimeApiMethod<
      Rv,
      (inherent: InherentData) => Promise<Array<OpaqueExtrinsic>>
    >;

    /**
     *
     * @callname: BlockBuilder_finalize_block
     **/
    finalizeBlock: GenericRuntimeApiMethod<Rv, () => Promise<Header>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TaggedTransactionQueue - 0xd2bc9897eed08f15
   * @version: 3
   **/
  taggedTransactionQueue: {
    /**
     * Validate the transaction.
     *
     * @callname: TaggedTransactionQueue_validate_transaction
     * @param {TransactionSource} source
     * @param {OpaqueExtrinsicLike} tx
     * @param {BlockHash} blockHash
     **/
    validateTransaction: GenericRuntimeApiMethod<
      Rv,
      (
        source: TransactionSource,
        tx: OpaqueExtrinsicLike,
        blockHash: BlockHash,
      ) => Promise<TransactionValidity>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: OffchainWorkerApi - 0xf78b278be53f454c
   * @version: 2
   **/
  offchainWorkerApi: {
    /**
     * Starts the off-chain task for given block header.
     *
     * @callname: OffchainWorkerApi_offchain_worker
     * @param {Header} header
     **/
    offchainWorker: GenericRuntimeApiMethod<
      Rv,
      (header: Header) => Promise<[]>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: GrandpaApi - 0xed99c5acb25eedf5
   * @version: 3
   **/
  grandpaApi: {
    /**
     * Get current GRANDPA authority set id.
     *
     * @callname: GrandpaApi_current_set_id
     **/
    currentSetId: GenericRuntimeApiMethod<Rv, () => Promise<SetId>>;

    /**
     * Get the current GRANDPA authorities and weights. This should not change except
     * for when changes are scheduled and the corresponding delay has passed.
     *
     * When called at block B, it will return the set of authorities that should be
     * used to finalize descendants of this block (B+1, B+2, ...). The block B itself
     * is finalized by the authorities from block B-1.
     *
     * @callname: GrandpaApi_generate_key_ownership_proof
     * @param {SetId} setId
     * @param {AccountId32Like} authorityId
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (
        setId: SetId,
        authorityId: AccountId32Like,
      ) => Promise<Option<OpaqueKeyOwnershipProof>>
    >;

    /**
     * Generates a proof of key ownership for the given authority in the
     * given set. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `set_id` as parameter the current
     * implementations ignore this parameter and instead rely on this
     * method being called at the correct block height, i.e. any point at
     * which the given set id is live on-chain. Future implementations will
     * instead use indexed data through an offchain worker, not requiring
     * older states to be available.
     *
     * @callname: GrandpaApi_grandpa_authorities
     **/
    grandpaAuthorities: GenericRuntimeApiMethod<
      Rv,
      () => Promise<AuthorityList>
    >;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: GrandpaApi_submit_report_equivocation_unsigned_extrinsic
     * @param {GrandpaEquivocationProof} equivocationProof
     * @param {OpaqueKeyOwnershipProof} keyOwnerProof
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        equivocationProof: GrandpaEquivocationProof,
        keyOwnerProof: OpaqueKeyOwnershipProof,
      ) => Promise<Option<[]>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BabeApi - 0xcbca25e39f142387
   * @version: 2
   **/
  babeApi: {
    /**
     * Return the configuration for BABE.
     *
     * @callname: BabeApi_configuration
     **/
    configuration: GenericRuntimeApiMethod<
      Rv,
      () => Promise<BabeConfiguration>
    >;

    /**
     * Returns information regarding the current epoch.
     *
     * @callname: BabeApi_current_epoch
     **/
    currentEpoch: GenericRuntimeApiMethod<Rv, () => Promise<BabeEpoch>>;

    /**
     * Returns the slot that started the current epoch.
     *
     * @callname: BabeApi_current_epoch_start
     **/
    currentEpochStart: GenericRuntimeApiMethod<Rv, () => Promise<Slot>>;

    /**
     * Returns information regarding the next epoch (which was already previously announced).
     *
     * @callname: BabeApi_next_epoch
     **/
    nextEpoch: GenericRuntimeApiMethod<Rv, () => Promise<BabeEpoch>>;

    /**
     * Generates a proof of key ownership for the given authority in the
     * current epoch. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `slot` as parameter the current
     * implementations ignores this parameter and instead relies on this
     * method being called at the correct block height, i.e. any point at
     * which the epoch for the given slot is live on-chain. Future
     * implementations will instead use indexed data through an offchain
     * worker, not requiring older states to be available.
     *
     * @callname: BabeApi_generate_key_ownership_proof
     * @param {Slot} slot
     * @param {AccountId32Like} authorityId
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (
        slot: Slot,
        authorityId: AccountId32Like,
      ) => Promise<Option<OpaqueKeyOwnershipProof>>
    >;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: BabeApi_submit_report_equivocation_unsigned_extrinsic
     * @param {BabeEquivocationProof} equivocationProof
     * @param {OpaqueKeyOwnershipProof} keyOwnerProof
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        equivocationProof: BabeEquivocationProof,
        keyOwnerProof: OpaqueKeyOwnershipProof,
      ) => Promise<Option<[]>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: AuthorityDiscoveryApi - 0x687ad44ad37f03c2
   * @version: 1
   **/
  authorityDiscoveryApi: {
    /**
     * Retrieve authority identifiers of the current and next authority set.
     *
     * @callname: AuthorityDiscoveryApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<Rv, () => Promise<Array<AccountId32>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: AccountNonceApi - 0xbc9d89904f5b923f
   * @version: 1
   **/
  accountNonceApi: {
    /**
     * The API to query account nonce (aka transaction index)
     *
     * @callname: AccountNonceApi_account_nonce
     * @param {AccountId32Like} accountId
     **/
    accountNonce: GenericRuntimeApiMethod<
      Rv,
      (accountId: AccountId32Like) => Promise<Nonce>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TransactionPaymentApi - 0x37c8bb1350a9a2a8
   * @version: 4
   **/
  transactionPaymentApi: {
    /**
     * The transaction info
     *
     * @callname: TransactionPaymentApi_query_info
     * @param {OpaqueExtrinsicLike} uxt
     * @param {number} len
     **/
    queryInfo: GenericRuntimeApiMethod<
      Rv,
      (uxt: OpaqueExtrinsicLike, len: number) => Promise<RuntimeDispatchInfo>
    >;

    /**
     * The transaction fee details
     *
     * @callname: TransactionPaymentApi_query_fee_details
     * @param {OpaqueExtrinsicLike} uxt
     * @param {number} len
     **/
    queryFeeDetails: GenericRuntimeApiMethod<
      Rv,
      (uxt: OpaqueExtrinsicLike, len: number) => Promise<FeeDetails>
    >;

    /**
     * Query the output of the current LengthToFee given some input
     *
     * @callname: TransactionPaymentApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<
      Rv,
      (length: number) => Promise<Balance>
    >;

    /**
     * Query the output of the current WeightToFee given some input
     *
     * @callname: TransactionPaymentApi_query_weight_to_fee
     * @param {Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<
      Rv,
      (weight: Weight) => Promise<Balance>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TransactionPaymentCallApi - 0xf3ff14d5ab527059
   * @version: 3
   **/
  transactionPaymentCallApi: {
    /**
     * Query information of a dispatch class, weight, and fee of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_info
     * @param {RawBytesLike} call
     * @param {number} len
     **/
    queryCallInfo: GenericRuntimeApiMethod<
      Rv,
      (call: RawBytesLike, len: number) => Promise<RuntimeDispatchInfo>
    >;

    /**
     * Query fee details of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_fee_details
     * @param {RawBytesLike} call
     * @param {number} len
     **/
    queryCallFeeDetails: GenericRuntimeApiMethod<
      Rv,
      (call: RawBytesLike, len: number) => Promise<FeeDetails>
    >;

    /**
     * Query the output of the current LengthToFee given some input
     *
     * @callname: TransactionPaymentCallApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<
      Rv,
      (length: number) => Promise<Balance>
    >;

    /**
     * Query the output of the current WeightToFee given some input
     *
     * @callname: TransactionPaymentCallApi_query_weight_to_fee
     * @param {Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<
      Rv,
      (weight: Weight) => Promise<Balance>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: SessionKeys - 0xab3c0572291feb8b
   * @version: 1
   **/
  sessionKeys: {
    /**
     * Generate a set of session keys with optionally using the given seed.
     * The keys should be stored within the keystore exposed via runtime
     * externalities.
     *
     * The seed needs to be a valid `utf8` string.
     *
     * Returns the concatenated SCALE encoded public keys.
     *
     * @callname: SessionKeys_generate_session_keys
     * @param {Option<BytesLike>} seed
     **/
    generateSessionKeys: GenericRuntimeApiMethod<
      Rv,
      (seed?: Option<BytesLike>) => Promise<Bytes>
    >;

    /**
     * Decode the given public session key
     *
     * Returns the list of public raw public keys + key typ
     *
     * @callname: SessionKeys_decode_session_keys
     * @param {BytesLike} encoded
     **/
    decodeSessionKeys: GenericRuntimeApiMethod<
      Rv,
      (encoded: BytesLike) => Promise<Option<Array<[Bytes, KeyTypeId]>>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: GenesisBuilder - 0xfbc577b9d747efd6
   * @version: 1
   **/
  genesisBuilder: {
    /**
     * Creates the default `GenesisConfig` and returns it as a JSON blob.
     *
     * This function instantiates the default `GenesisConfig` struct for the runtime and serializes it into a JSON
     * blob. It returns a `Vec<u8>` containing the JSON representation of the default `GenesisConfig`.
     *
     * @callname: GenesisBuilder_create_default_config
     **/
    createDefaultConfig: GenericRuntimeApiMethod<Rv, () => Promise<Bytes>>;

    /**
     * Build `GenesisConfig` from a JSON blob not using any defaults and store it in the storage.
     *
     * This function deserializes the full `GenesisConfig` from the given JSON blob and puts it into the storage.
     * If the provided JSON blob is incorrect or incomplete or the deserialization fails, an error is returned.
     * It is recommended to log any errors encountered during the process.
     *
     * Please note that provided json blob must contain all `GenesisConfig` fields, no defaults will be used.
     *
     * @callname: GenesisBuilder_build_config
     * @param {BytesLike} json
     **/
    buildConfig: GenericRuntimeApiMethod<
      Rv,
      (json: BytesLike) => Promise<Result<[], Text>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
}

// Generated by dedot cli



type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = MelodieRuntimeRuntimeCallLike,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord>>);

type TxCall<Rv extends RpcVersion> = (
  ...args: any[]
) => ChainSubmittableExtrinsic<Rv>;

interface ChainTx<Rv extends RpcVersion>
  extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     *
     * @param {MelodieRuntimeRuntimeTask} task
     **/
    doTask: GenericTxCall<
      Rv,
      (task: MelodieRuntimeRuntimeTask) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'DoTask';
            params: { task: MelodieRuntimeRuntimeTask };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: {
              source: MultiAddressLike;
              dest: MultiAddressLike;
              value: bigint;
            };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: {
              direction: PalletBalancesAdjustmentDirection;
              delta: bigint;
            };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Babe`'s transaction calls
   **/
  babe: {
    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocation';
            params: {
              equivocationProof: SpConsensusSlotsEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: {
              equivocationProof: SpConsensusSlotsEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     *
     * @param {SpConsensusBabeDigestsNextConfigDescriptor} config
     **/
    planConfigChange: GenericTxCall<
      Rv,
      (
        config: SpConsensusBabeDigestsNextConfigDescriptor,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'PlanConfigChange';
            params: { config: SpConsensusBabeDigestsNextConfigDescriptor };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ImOnline`'s transaction calls
   **/
  imOnline: {
    /**
     * ## Complexity:
     * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
     * - `O(K)`: decoding of length `K`
     *
     * @param {PalletImOnlineHeartbeat} heartbeat
     * @param {PalletImOnlineSr25519AppSr25519Signature} signature
     **/
    heartbeat: GenericTxCall<
      Rv,
      (
        heartbeat: PalletImOnlineHeartbeat,
        signature: PalletImOnlineSr25519AppSr25519Signature,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ImOnline';
          palletCall: {
            name: 'Heartbeat';
            params: {
              heartbeat: PalletImOnlineHeartbeat;
              signature: PalletImOnlineSr25519AppSr25519Signature;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ValidatorSet`'s transaction calls
   **/
  validatorSet: {
    /**
     * Add a new validator.
     *
     * New validator's session keys should be set in Session pallet before
     * calling this.
     *
     * The origin can be configured using the `AddRemoveOrigin` type in the
     * host runtime. Can also be set to sudo/root.
     *
     * @param {AccountId32Like} validatorId
     **/
    addValidator: GenericTxCall<
      Rv,
      (validatorId: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ValidatorSet';
          palletCall: {
            name: 'AddValidator';
            params: { validatorId: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Remove a validator.
     *
     * The origin can be configured using the `AddRemoveOrigin` type in the
     * host runtime. Can also be set to sudo/root.
     *
     * @param {AccountId32Like} validatorId
     **/
    removeValidator: GenericTxCall<
      Rv,
      (validatorId: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ValidatorSet';
          palletCall: {
            name: 'RemoveValidator';
            params: { validatorId: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {MelodieRuntimePalletsSessionSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      Rv,
      (
        keys: MelodieRuntimePalletsSessionSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'SetKeys';
            params: {
              keys: MelodieRuntimePalletsSessionSessionKeys;
              proof: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'PurgeKeys';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Grandpa`'s transaction calls
   **/
  grandpa: {
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocation';
            params: {
              equivocationProof: SpConsensusGrandpaEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: {
              equivocationProof: SpConsensusGrandpaEquivocationProof;
              keyOwnerProof: SpSessionMembershipProof;
            };
          };
        }
      >
    >;

    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     *
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     *
     * Only callable by root.
     *
     * @param {number} delay
     * @param {number} bestFinalizedBlockNumber
     **/
    noteStalled: GenericTxCall<
      Rv,
      (
        delay: number,
        bestFinalizedBlockNumber: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'NoteStalled';
            params: { delay: number; bestFinalizedBlockNumber: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<MelodieRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (
        calls: Array<MelodieRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: MelodieRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<MelodieRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (
        calls: Array<MelodieRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {MelodieRuntimeOriginCaller} asOrigin
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: MelodieRuntimeOriginCaller,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: {
              asOrigin: MelodieRuntimeOriginCaller;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<MelodieRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (
        calls: Array<MelodieRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<MelodieRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {MelodieRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: MelodieRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: {
              call: MelodieRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * @param {MultiAddressLike} account
     **/
    addRegistrar: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddRegistrar';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * @param {SharedRuntimeIdentityIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      Rv,
      (info: SharedRuntimeIdentityIdentityInfo) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetIdentity';
            params: { info: SharedRuntimeIdentityIdentityInfo };
          };
        }
      >
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * @param {Array<[AccountId32Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      Rv,
      (subs: Array<[AccountId32Like, Data]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetSubs';
            params: { subs: Array<[AccountId32Like, Data]> };
          };
        }
      >
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     **/
    clearIdentity: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ClearIdentity';
          };
        }
      >
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RequestJudgement';
            params: { regIndex: number; maxFee: bigint };
          };
        }
      >
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      Rv,
      (regIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'CancelRequest';
            params: { regIndex: number };
          };
        }
      >
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      Rv,
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFee';
            params: { index: number; fee: bigint };
          };
        }
      >
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * @param {number} index
     * @param {MultiAddressLike} new_
     **/
    setAccountId: GenericTxCall<
      Rv,
      (
        index: number,
        new_: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetAccountId';
            params: { index: number; new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * @param {number} index
     * @param {bigint} fields
     **/
    setFields: GenericTxCall<
      Rv,
      (
        index: number,
        fields: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFields';
            params: { index: number; fields: bigint };
          };
        }
      >
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     *
     * @param {number} regIndex
     * @param {MultiAddressLike} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        target: MultiAddressLike,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ProvideJudgement';
            params: {
              regIndex: number;
              target: MultiAddressLike;
              judgement: PalletIdentityJudgement;
              identity: H256;
            };
          };
        }
      >
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * @param {MultiAddressLike} target
     **/
    killIdentity: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillIdentity';
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RenameSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     **/
    removeSub: GenericTxCall<
      Rv,
      (sub: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveSub';
            params: { sub: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'QuitSub';
          };
        }
      >
    >;

    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up their allocation, they
     * should just issue (or request via governance) a new `add_username_authority` call.
     *
     * @param {MultiAddressLike} authority
     * @param {BytesLike} suffix
     * @param {number} allocation
     **/
    addUsernameAuthority: GenericTxCall<
      Rv,
      (
        authority: MultiAddressLike,
        suffix: BytesLike,
        allocation: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddUsernameAuthority';
            params: {
              authority: MultiAddressLike;
              suffix: BytesLike;
              allocation: number;
            };
          };
        }
      >
    >;

    /**
     * Remove `authority` from the username authorities.
     *
     * @param {MultiAddressLike} authority
     **/
    removeUsernameAuthority: GenericTxCall<
      Rv,
      (authority: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsernameAuthority';
            params: { authority: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * The authority must have an `allocation`. Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     *
     * @param {MultiAddressLike} who
     * @param {BytesLike} username
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    setUsernameFor: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        username: BytesLike,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetUsernameFor';
            params: {
              who: MultiAddressLike;
              username: BytesLike;
              signature: SpRuntimeMultiSignature | undefined;
            };
          };
        }
      >
    >;

    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    acceptUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AcceptUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    removeExpiredApproval: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveExpiredApproval';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Set a given username as the primary. The username should include the suffix.
     *
     * @param {BytesLike} username
     **/
    setPrimaryUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetPrimaryUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove a username that corresponds to an account with no identity. Exists when a user
     * gets a username but then calls `clear_identity`.
     *
     * @param {BytesLike} username
     **/
    removeDanglingUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveDanglingUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      Rv,
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Schedule';
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Cancel';
            params: { when: number; index: number };
          };
        }
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamed';
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      Rv,
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleAfter';
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamedAfter';
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      Rv,
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetry';
            params: { task: [number, number]; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetryNamed';
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      Rv,
      (task: [number, number]) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetry';
            params: { task: [number, number] };
          };
        }
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetryNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Sudo`'s transaction calls
   **/
  sudo: {
    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     *
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    sudo: GenericTxCall<
      Rv,
      (call: MelodieRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'Sudo';
            params: { call: MelodieRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {MelodieRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    sudoUncheckedWeight: GenericTxCall<
      Rv,
      (
        call: MelodieRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SudoUncheckedWeight';
            params: {
              call: MelodieRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     *
     * @param {MultiAddressLike} new_
     **/
    setKey: GenericTxCall<
      Rv,
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SetKey';
            params: { new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {MultiAddressLike} who
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    sudoAs: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SudoAs';
            params: {
              who: MultiAddressLike;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Permanently removes the sudo key.
     *
     * **This cannot be un-done.**
     *
     **/
    removeKey: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'RemoveKey';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {MelodieRuntimePalletsProxyProxyType | undefined} forceProxyType
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: MultiAddressLike;
              forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: MelodieRuntimePalletsProxyProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: {
              delegate: MultiAddressLike;
              proxyType: MelodieRuntimePalletsProxyProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: MelodieRuntimePalletsProxyProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: {
              delegate: MultiAddressLike;
              proxyType: MelodieRuntimePalletsProxyProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: MelodieRuntimePalletsProxyProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: {
              proxyType: MelodieRuntimePalletsProxyProxyType;
              delay: number;
              index: number;
            };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {MelodieRuntimePalletsProxyProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: MultiAddressLike,
        proxyType: MelodieRuntimePalletsProxyProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: MultiAddressLike;
              proxyType: MelodieRuntimePalletsProxyProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {MelodieRuntimePalletsProxyProxyType | undefined} forceProxyType
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: MelodieRuntimePalletsProxyProxyType | undefined;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {MelodieRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId32Like>,
        call: MelodieRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: {
              otherSignatories: Array<AccountId32Like>;
              call: MelodieRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {MelodieRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: MelodieRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: MelodieRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      Rv,
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'NotePreimage';
            params: { bytes: BytesLike };
          };
        }
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnnotePreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'RequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnrequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Ensure that the a bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      Rv,
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'EnsureUpdated';
            params: { hashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Stakeholders`'s transaction calls
   **/
  stakeholders: {
    /**
     *
     * @param {MiddsStakeholderStakeholder} midds
     **/
    register: GenericTxCall<
      Rv,
      (midds: MiddsStakeholderStakeholder) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Stakeholders';
          palletCall: {
            name: 'Register';
            params: { midds: MiddsStakeholderStakeholder };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     * @param {MiddsStakeholderEditableStakeholderField} fieldData
     **/
    updateField: GenericTxCall<
      Rv,
      (
        middsId: H256,
        fieldData: MiddsStakeholderEditableStakeholderField,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Stakeholders';
          palletCall: {
            name: 'UpdateField';
            params: {
              middsId: H256;
              fieldData: MiddsStakeholderEditableStakeholderField;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     **/
    unregister: GenericTxCall<
      Rv,
      (middsId: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Stakeholders';
          palletCall: {
            name: 'Unregister';
            params: { middsId: H256 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MusicalWorks`'s transaction calls
   **/
  musicalWorks: {
    /**
     *
     * @param {MiddsSongSong} midds
     **/
    register: GenericTxCall<
      Rv,
      (midds: MiddsSongSong) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MusicalWorks';
          palletCall: {
            name: 'Register';
            params: { midds: MiddsSongSong };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     * @param {MiddsSongSongEditableField} fieldData
     **/
    updateField: GenericTxCall<
      Rv,
      (
        middsId: H256,
        fieldData: MiddsSongSongEditableField,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MusicalWorks';
          palletCall: {
            name: 'UpdateField';
            params: { middsId: H256; fieldData: MiddsSongSongEditableField };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} middsId
     **/
    unregister: GenericTxCall<
      Rv,
      (middsId: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MusicalWorks';
          palletCall: {
            name: 'Unregister';
            params: { middsId: H256 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}

// Generated by dedot cli



interface VersionedAllfeatApi<Rv extends RpcVersion>
  extends GenericSubstrateApi<Rv> {
  rpc: ChainJsonRpcApis<Rv>;
  consts: ChainConsts<Rv>;
  query: ChainStorage<Rv>;
  errors: ChainErrors<Rv>;
  events: ChainEvents<Rv>;
  call: RuntimeApis<Rv>;
  tx: ChainTx<Rv>;
}

/**
 * @name: AllfeatApi
 * @specVersion: 100
 **/
interface AllfeatApi {
  legacy: VersionedAllfeatApi<RpcLegacy>;
  v2: VersionedAllfeatApi<RpcV2>;
}

type AllfeatNetwork = 'melodie' | 'devnet';
type MiddsSubstrateType = MiddsStakeholderStakeholder | MiddsSongSong;

declare class AllfeatProvider extends WsProvider {
    /**
     * Create a Provider instance for a specific Allfeat network
     * @param networkOrUrl - Network to connect to ('melodie' or 'devnet' or custom URL)
     */
    constructor(networkOrUrl: AllfeatNetwork | string);
    /**
     * List all supported networks
     */
    static getSupportedNetworks(): AllfeatNetwork[];
}

declare class AllfeatClient extends DedotClient<AllfeatApi> {
    constructor(provider: AllfeatProvider);
    static new(provider: AllfeatProvider): Promise<AllfeatClient>;
}

interface IMiddsInput<T, SubstrateType> {
    get Value(): T | null;
    get Name(): string;
    get isValid(): boolean;
    set Value(value: T | null);
    intoSubstrateType(): SubstrateType;
}
interface IMiddsString extends IMiddsInput<string, `0x${string}`> {
    get MaxLength(): number;
    get Regex(): RegExp | null;
}
declare abstract class MiddsInput<T, SubstrateType> implements IMiddsInput<T, SubstrateType> {
    private value;
    private readonly name;
    protected constructor(name: string);
    get Value(): T | null;
    set Value(value: T | null);
    get Name(): string;
    abstract get isValid(): boolean;
    abstract intoSubstrateType(): SubstrateType;
}
declare abstract class MiddsString extends MiddsInput<string, `0x${string}`> implements IMiddsString {
    private readonly _maxLength;
    private readonly _regex;
    protected constructor(name: string, regex: RegExp | null, maxLength: number);
    get MaxLength(): number;
    get Regex(): RegExp | null;
    intoSubstrateType(): `0x${string}`;
    get isValid(): boolean;
}
declare abstract class MiddsNumber extends MiddsInput<number, bigint> {
    protected constructor(name: string);
    intoSubstrateType(): bigint;
}

declare abstract class Midds implements IMidds {
    private readonly _palletName;
    data: IMiddsInput<any, any>[];
    protected constructor(palletName: string, data: IMiddsInput<any, any>[]);
    abstract parseIntoSubstrateType(): MiddsSubstrateType;
    get isValid(): boolean;
    createRegisterExtrinsic(client: AllfeatClient): ISubmittableExtrinsic;
    register(client: AllfeatClient, account: KeyringPair | string, callback?: Callback<ISubmittableResult>): Promise<IRegisterResult>;
}
interface IMidds {
    data: IMiddsInput<any, any>[];
    /**
     * Ensure that the Midds have at least one required field not empty.
     */
    get isValid(): boolean;
    /**
     * Parse this actual Midds instance into the Substrate API ready Midds type.
     */
    parseIntoSubstrateType(): MiddsSubstrateType;
    /**
     * Create an extrinsic to submit to the network from the current Midds data
     * @param client The client to create the extrinsic from.
     */
    createRegisterExtrinsic(client: AllfeatClient): ISubmittableExtrinsic;
    register(client: AllfeatClient, account: KeyringPair | string): Promise<IRegisterResult>;
    register(client: AllfeatClient, account: KeyringPair | string, callback: Callback<ISubmittableResult>): Promise<IRegisterResult>;
}
interface IRegisterResult {
    readonly txHash: string;
    readonly blockHash: string;
    readonly blockNumber: number;
    readonly middsHash: string;
    readonly provider: string;
    readonly collateralCost: bigint;
}

declare class Stakeholder extends Midds {
    constructor();
    set IPI(IPI: number | null);
    set FirstName(FirstName: string | null);
    set LastName(LastName: string | null);
    set Nickname(Nickname: string | null);
    get IPI(): number | null;
    get FirstName(): string | null;
    get LastName(): string | null;
    get Nickname(): string | null;
    parseIntoSubstrateType(): MiddsStakeholderStakeholder;
}

export { AllfeatClient, type AllfeatNetwork, AllfeatProvider, type IMidds, type IMiddsInput, type IMiddsString, type IRegisterResult, Midds, MiddsInput, MiddsNumber, MiddsString, type MiddsSubstrateType, Stakeholder };
